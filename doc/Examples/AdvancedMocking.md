<!-- This file was auto-generated by SweetDoky -->
# Advanced mocking 

Represents advanced mocking functionalities for handling abstract or virtual methods
and simulating complex behaviors in unit tests.

__config__: Unless otherwise specified the `config` parameter is the configuration object for [Demo class](References.md#method-demo-class).<br/>

<a name="MockingUsingCall"></a>
## Mocking using call 

Mocking for all abstract or virtual methods can be done using the `call` argument.
This is the most versatile way of mocking, but also the one requiring most code.

When one or more arguments are not important for the returned result, the value can be replaced with `_`

```csharp
config.Greeting(call: (name, age) => $"{name} is {age} years old.");

// If one or more arguments are not important for the returned result, the value can be replaced with <c>_</c>

config.Greeting(call: (name,_) => $"Age of {name} is unknown.");
```

The example specifies that the mock should return a generated text string for each call to the `Greeting` method.

The `call` argument can also be used to mimic more complex behavior like in [Mocking complex behavior using call](AdvancedMocking.md#mocking-complex-behavior-using-call)

<a name="MockingOutUsingCall"></a>
## Mocking out using call 

Mocks methods containing `out` parameters by using a delegate that explicitly defines the output variable.
This allows the mock to assign a value to the `out` argument before returning a result.

```csharp
config.TryGetAge((_, out age) =>
{
    age = 53;
    return true;
});
```

When mocking `out` parameters, the argument in the lambda is prefixed with `out`.
The provided value is assigned within the delegate body, mimicking how a real implementation would behave.

<a name="MockingNoReturnValueUsingCall"></a>
## Mocking no return value using call 

Mocks methods that do not return a value (or return a `Task` without a result) by providing an action or a task-returning delegate.
This is useful for verifying side effects or ensuring asynchronous methods complete as expected.

```csharp
config.SetAge((_, _, _) => Task.CompletedTask);
```

In this example, the mock for `SetAge` returns `Task.CompletedTask`, which is the standard way to mock a non-generic `Task` return type.

<a name="MockingComplexBehaviorUsingCall"></a>
## Mocking complex behavior using call 

Handles complex logic or conditional branching within a mock by using a local function or a method group.
This keeps the configuration readable when the mock logic involves switches, custom exceptions, or state-dependent results.

```csharp
config.GetAgeAsync(Complex);

return;

Task<int> Complex(string name, CancellationToken token)
{
    return name switch
    {
        "Oswald" => Task.FromResult(53),
        "Bingo" => Task.FromResult(49),
        null => Task.FromCanceled<int>(token),
        _ => throw new UnknownPersonException(name)
    };
}
```

This approach is preferred over inline lambdas when the logic spans multiple lines or requires pattern matching.
It also demonstrates how to handle `CancellationToken` and throw custom exceptions like `UnknownPersonException` within a mock.

<a name="SpecifyingSpecificDependencies"></a>
## Specifying specific dependencies 

Demonstrates the process of specifying specific dependencies when mocking in unit tests.
This method sets up a fixture and overrides a dependency with a specific implementation.

```csharp
// Arrange
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency.StringProperty("Initial value"); // Will be ignored
});

var implementation = new DependencyImplementation { StringProperty = "Implementation value" };
var sut = fixture.CreateDemoService(
    demoDependency: implementation
);

// ACT
var actual = sut.GetStringProperty();

// Assert
Assert.Equal("Implementation value", actual);
```

This method illustrates how to configure mock dependencies during test setup, allowing a custom implementation
to replace a mocked dependency. It highlights the flexibility to ensure that tests align with specific requirements
by directly providing non-default implementations.

 > [!WARNING]
 > This is useful for doing component testing and subsystem testing, but please note that calls to a specified implementation are not logged.

<a name="SharingPartsOfTheFixtureConfiguration"></a>
## Sharing parts of the fixture configuration 

When a larger part of the configuration is identical in several tests, it can be moved to a shared location.

Sharing the configuration is preferred over sharing the fixture itself since it allows for more granular control while still reducing duplication.

```csharp
// Arrange
var fixture = Fixture.DemoService(config => 
    ConfigGetAgeAsync(config.demoDependency)
    );
var sut = fixture.CreateDemoService();

// ACT
var actual = sut.GetStringProperty();

// Assert
Assert.Equal("Configured value", actual);

return;

// This configures the demo dependency.
void ConfigGetAgeAsync(MockOf_IDemoDependency.MockConfig demoDependency) =>
    demoDependency
        .StringProperty("Configured value")
        .GetAgeAsync(53);
```

 > [!TIP]Targeting the specific dependency allows for the configuration to be shared between different fixtures with the same dependency

