<!-- This file was auto-generated by SweetDoky -->
# Advanced mocking 

## Mocking using call 

Mocking for all abstract or virtual methods can be done using the `call` argument.
This is the most versatile way of mocking, but also the one requiring most code.

When one or more arguments are not important for the returned result, the value can be replaced with `_`

```csharp
config.Greeting(call: (name, age) => $"{name} is {age} years old.");
```

The example specifies that the mock should return a generated text string for each call to the `Greeting` method.

The `call` argument can also be used to mimic more complex behavior like in [Mocking complex behavior using call](AdvancedMocking.md#mocking-complex-behavior-using-call)

## Mocking out using call 

Mocks methods containing `out` parameters by using a delegate that explicitly defines the output variable.
This allows the mock to assign a value to the `out` argument before returning a result.

```csharp
config.TryGetAge((_, out age) =>
{
    age = 53;
    return true;
});
```

When mocking `out` parameters, the argument in the lambda is prefixed with `out`.
The provided value is assigned within the delegate body, mimicking how a real implementation would behave.

## Mocking no return value using call 

Mocks methods that do not return a value (or return a `Task` without a result) by providing an action or a task-returning delegate.
This is useful for verifying side effects or ensuring asynchronous methods complete as expected.

```csharp
config.SetAge((_, _, _) => Task.CompletedTask);
```

In this example, the mock for `SetAge` returns `Task.CompletedTask`, which is the standard way to mock a non-generic `Task` return type.

## Mocking complex behavior using call 

Handles complex logic or conditional branching within a mock by using a local function or a method group.
This keeps the configuration readable when the mock logic involves switches, custom exceptions, or state-dependent results.

```csharp
config.GetAgeAsync(Complex);

return;

Task<int> Complex(string name, CancellationToken token)
{
    return name switch
    {
        "Oswald" => Task.FromResult(53),
        "Bingo" => Task.FromResult(49),
        null => Task.FromCanceled<int>(token),
        _ => throw new UnknownPersonException(name)
    };
}
```

This approach is preferred over inline lambdas when the logic spans multiple lines or requires pattern matching.
It also demonstrates how to handle `CancellationToken` and throw custom exceptions like `UnknownPersonException` within a mock.

## Mock vs fixture 

Compares the use of a fixture with manually created mocks when setting up a System Under Test (SUT).
This method demonstrates two approaches for arranging dependencies for a class under test:
using the generated fixture for dependency resolution, or individually mocking each required dependency.

Both methods initialize the DemoService class with a collection of mocked components, and the resulting SUT is functionally identical.

The fixture approach has benefits when it comes to asserting calls across dependencies. See 

```csharp
// Arrange using fixture
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency.StringProperty("Initial value"); // Will be ignored
});
var sutUsingFixture = fixture.CreateDemoService();

// Arrange using mock
var mockTimeProvider = Mock.TimeProvider();
var mockHttpClient = Mock.HttpClient();
var mockOptions = Mock.IOptions<DemoServiceConfig>();
var mockDemoDependency = Mock.IDemoDependency(config => config.StringProperty("Initial value"));
var mockLogger = Mock.ILogger<DemoService>();
var sutUsingMock = new DemoService(mockTimeProvider, mockHttpClient, mockOptions, mockDemoDependency, mockLogger);
```

The fixture-based approach provides a streamlined configuration for creating the SUT with required
dependencies pre-initialized. This approach greatly reduces boilerplate code.

The mock-based approach offers fine-grained control by manually creating and configuring individual mocks
for each dependency. While this approach allows for changing dependencies upfront, the same effect can be done using .

In the example some of the build in mocks are using. For more details on them see .

## Specifying specific dependencies 

Demonstrates the process of specifying specific dependencies when mocking in unit tests.
This method sets up a fixture and overrides a dependency with a specific implementation.

```csharp
// Arrange
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency.StringProperty("Initial value"); // Will be ignored
});

var implementation = new DependencyImplementation { StringProperty = "Implementation value" };
var sut = fixture.CreateDemoService(
    demoDependency: implementation
);

// ACT
var actual = sut.GetStringProperty();

// Assert
Assert.Equal("Implementation value", actual);
```

This method illustrates how to configure mock dependencies during test setup, allowing a custom implementation
to replace a mocked dependency. It highlights the flexibility to ensure that tests align with specific requirements
by directly providing non-default implementations.

This is useful for doing component testing and subsystem testing, but please note that calls to a specified implementation are not logged.

