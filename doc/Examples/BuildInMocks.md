<!-- This file was auto-generated by SweetDoky -->
# Build in mocks 

Although the generated mocks supports mock use-cases, a few well-known dependencies have a build-in version that offers more options.
- ILogger: Writes all logs to the Call log for easy inspection.
- HttpClient: Handles the internal issues when trying to mock HttpClient. Also, provides helper methods to generate replies.
- TimeProvider: Defaults to using `TimeProvider.System` but allows for using `FakeTimeProvider`
- IOptions: Simplifies setting options by providing default values and a simple initializer.

<a name="Build_in_mock_for_ILogger"></a>
## Build in mock for ILogger 

Sets up a test environment for a class with an [ILogger](T:Microsoft.Extensions.Logging.ILogger) dependency.
Configure a mock for the [ILogger](T:Microsoft.Extensions.Logging.ILogger) and provides testing capabilities related to log messages logged by the dependent class.
The test fixture is created for the `ClassWithILoggerDependency` and the logging level
is set to `LogLevel.Trace`. The method tests log outputs by invoking the
`WriteToTheLog` method and retrieves all logged messages for verification.

```csharp
// Arrange
var fixture = Fixture.ClassWithDependencies(
    config => config.logger.SetLogLevel(LogLevel.Trace)
    // Or leave uninitialized to keep log level at Information.
);
var sut = fixture.CreateClassWithDependencies();

// Act
sut.WriteToTheLog();

// Assert
var logs = fixture.Calls.logger;

Assert.Equal(7, logs.All().Count());

var actual = Assert.Single(logs.Log(arguments => arguments.logLevel == LogLevel.Critical));
Assert.Equal("Critical message", actual.message);
```

 > [!NOTE]
 > If loglevel should be `LogLevel.Information` the config section can be removed.

<a name="Build_in_mock_for_HttpClient"></a>
## Build in mock for HttpClient 

Sets up a test environment for a class with an [Http Client](T:System.Net.Http.HttpClient) dependency.
Configures a mock for the [Http Client](T:System.Net.Http.HttpClient) to simulate HTTP responses and provides testing
capabilities for verifying HTTP call interactions made by the dependent class.
The test fixture is created for the `ClassWithHttpClientDependency`, which uses
[Http Client](T:System.Net.Http.HttpClient) to perform REST service calls. The method tests the response and verifies
the exact HTTP request details.

```csharp
// Arrange
var fixture = Fixture.ClassWithDependencies(config => 
    config.httpClient
        .Send(message => message.ReplyOk().WithContent(new StringContent("Hello, World!"), "application/text"))
    );
var sut = fixture.CreateClassWithDependencies();

// Act
var actual = await sut.CallRestService("world");

// Assert
Assert.Equal("Hello, World!", actual);

var httpClientLogs = fixture.Calls.httpClient;
var actualHttpCall = Assert.Single(httpClientLogs.Send());
Assert.Equal("/GetGreeting/world", actualHttpCall.request?.RequestUri?.ToString());
```

 > [!NOTE]
 > While the methods `Send` and `SendAsync` function the same way and can be used interchangeably, `SendAsync` allows for setting up more complex scenarios involving timeouts and cancellations.

<a name="Build_in_mock_for_TimeProvider"></a>
## Build in mock for TimeProvider 

Configures a mock for the [Time Provider](T:System.TimeProvider), enabling control over the system clock for testing purposes.
This method prepares the test fixture for the `ClassWithTimeProviderDependency` and allows initialization
of the mock time provider with a specific date and time. Alternatively, the `TimeProvider.System`
can be used without any custom initialization.

```csharp
// Arrange
var fakeTimeProvider = new FakeTimeProvider(new DateTime(2023, 10, 1, 12, 0, 0));
var fixture = Fixture.ClassWithDependencies(config =>
{
    config.provider.GetUtcNow(new DateTime(2023, 10, 1, 12, 0, 0));
    // Or
    config.provider.Initialize(fakeTimeProvider);
    // Or leave uninitialized to use <c>TimeProvider.System</c>
});
var sut = fixture.CreateClassWithDependencies();

// Act
var actual = sut.WhatsTheTime();

// Assert
Assert.Equal("The time is 12:00 PM", actual);
```

 > [!IMPORTANT]
 > While it is possible to create a consistent concept of time by individually setting up each method and property of the time provider
 > it is recommended to use the [FakeTimeProvider](https://learn.microsoft.com/en-us/dotnet/standard/datetime/timeprovider-overview#faketimeprovider-implementation)

<a name="Build_in_mock_for_IOptions"></a>
## Build in mock for IOptions 

Configures a mock for IOptions&lt;TOptions&gt;, allowing default or custom option values to be defined.
The method creates a test fixture for the `ClassWithIOptionsDependency` and verifies behavior based on the
provided option values by invoking the `GetOptionName` method of the class under test.

```csharp
// Arrange
var fixture = Fixture.ClassWithDependencies(config => 
    config.options.Value(new(){Name = "Another name"})
    // Or leave uninitialized to get the default values.
);
var sut = fixture.CreateClassWithDependencies();

// Act
var actual = sut.GetOptionName();

// Assert
Assert.Equal("Another name", actual);
```

The options can be customized using the `config.options.Value` during fixture setup, or left uninitialized for default values.

<a name="ClassWithDependencies"></a>
## Class with dependencies 

Represents a class that depends on various external components, such as HttpClient, a time provider, options,
and a logger. Provides functionality for making REST API calls, querying the current time, retrieving options values,
and writing log messages at different levels.

```csharp
public partial class ClassWithDependencies(HttpClient httpClient, TimeProvider provider, IOptions<ClassWithDependencies.MyOptions> options, ILogger<ClassWithDependencies> logger)
{
    public async Task<string> CallRestService(string name) => 
        await httpClient.GetStringAsync($"/GetGreeting/{name}");

    public string WhatsTheTime() => 
        $"The time is {provider.GetUtcNow():t}";
    
    public string GetOptionName() => 
        options.Value.Name;
    
    public class MyOptions
    {
        public string Name { get; set; } = "Some name";
    }
    
    public void WriteToTheLog()
    {
        logger.LogTrace("Trace message");
        logger.LogDebug("Debug message");
        logger.LogInformation("Information message");
        logger.LogWarning("Warning message");
        logger.LogError("Error message");
        logger.LogCritical("Critical message");
        LogLoggingUsingTechniqueAlsoWorks(logger, "LogMethod");
    }

    [LoggerMessage(LogLevel.Information, "Logging using {technique} also works")]
    static partial void LogLoggingUsingTechniqueAlsoWorks(ILogger<ClassWithDependencies> logger, string technique);
}
```

