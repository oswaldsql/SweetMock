<!-- This file was auto-generated by SweetDoky -->
# Return simple values 

<a name="TLDR"></a>
## TL;DR 

For most mocking cases returning simple values is enough.
Methods, properties, and indexers can be configured to return a simple value by using the `returns`/`value` argument.

```csharp
Mock.DemoInterface(config =>
{
    config
        .StandardMethod(returns: "return value")

        .MethodReturningVoid()
        
        .AsyncMethod(returns: Task.FromResult(67))
        // or
        .AsyncMethod(returnAsTasks: 67)
        
        .MethodWithOutParameter(returns: true, out_age: 53)
        
        .SimpleProperty(value: "property value");
});
```

 > [!NOTE]
 > Argument names can be omitted but are kept here for clarity

<a name="MockingUsingReturns"></a>
## Mocking using returns 

Mocking the return of a simple value can be done using the `returns` argument.
Multiple calls to the method will return the same value.

```csharp
config.Greeting(returns: "Oswald is 53 years old.");
```

If overloaded methods have the same return type, all will be set. To avoid this behavior, use the `call` argument to target specific overloads instead.

 > [!WARNING]
 > Be aware that if the return type is a mutable object, any changes to that object will persist.

<a name="MockingUsingReturnValues"></a>
## Mocking using return values 

Mocking the return a sequence of simple values can be done using the `returnValues` argument.

If the method is call more than times than the specified number of values a `NotExplicitlyMockedException` is thrown.

```csharp
config.Greeting(returnValues: ["Oswald is 53 years old.", "Bingo is 49 years old."]);
```

If overloaded methods have the same return type, all will be set. To avoid this behavior, use the `call` argument instead.

Overloaded methods have their own iteration.

 > [!WARNING]
 > Be aware that if the return type is a mutable object, any changes to that object will affect other usages of that object.

<a name="MockingAsyncUsingReturnAsTasks"></a>
## Mocking async using return as tasks 

Mocking methods returning `Task` or `ValueTask` can also be done using the `returns` argument.

Either return a Task/ValueTask object or simply the raw value which will be wrapped in a Task/ValueTask.

```csharp
config.GetAgeAsync(returns: Task.FromResult(53));
// or
config.GetAgeAsync(returnAsTasks: 53);
```

 > [!IMPORTANT] Although it is possible to have Task run code, it is not recommended in this context. Instead, use the `call` argument.

<a name="MockingOutUsingReturns"></a>
## Mocking out using returns 

Mocking methods with `out` parameters can also be done using the return arguments.

```csharp
config.TryGetAge(returns: true, out_age: 53);
```

 > [!NOTE]
 > The `out` must always be specified, even if the value is not important for the returned result. This is due to the way the out parameter is handled internally.

<a name="MockingNoReturnValueUsingNoArguments"></a>
## Mocking no return value using no arguments 

Methods returning `void` can be marked as being mocked by calling the configuration method without arguments.
This will simply accept any call to the method.

```csharp
config.SetAge();
```

 > [!NOTE]
 > Not marking a void method this way will make the mock throw an exception if the method is called.

