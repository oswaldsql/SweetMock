<!-- This file was auto-generated by SweetDoky -->
# General setup and initialization 

## Attribute usage 

Mock and Fixture attributes can be placed on Classes and is the indicator for SweetMock to create a Mock or Fixture for the specified targets.

```csharp
[Mock<IDemoDependency>]
[Fixture<DemoService>]
public class AttributeUsage
{
    [Fact]
    public void AttributeOnMethod()
    {
        var mock = Mock.IDemoDependency(config => config.StringProperty("test"));
        Assert.Equal("test", mock.StringProperty);
        // or
        var fixture = Fixture.DemoService(config => config.demoDependency.StringProperty("test"));
        var sut = fixture.CreateDemoService();
        Assert.Equal("test", sut.GetStringProperty());
    }
}
```

Mocks and fixtures can be added multiple times in different files but will only be created once.
Mocks and fixture attributes can also be added to assemblies, methods, properties and a lot of other targets. But generally adding them to test classes is recommended.

## Creating fixture 

Fixtures simplify creating all the mocks required for a service.
For each dependency a configuration object is created allowing configuration of the mock.

```csharp
// Arrange
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency.StringProperty("Initial value");
});
var sut = fixture.CreateDemoService();

// ACT
var actual = sut.GetStringProperty();

// Assert
Assert.Equal("Initial value", actual);
```

The configuration of the fixture can also be access by calling fixture.Config allowing for modifying the configuration after creating the sut.
It is recommended to keep this to a minimum since it makes the configuration harder to read.

## Uninitialized mocks throw exceptions 

Calling a method that is not mocked will result in a `NotExplicitlyMockedException` exception being thrown.
The exception details which method on which mock was called.

```csharp
var mock = Mock.MethodDemoClass(config => { });

var actual = Record.Exception(() => mock.Greeting("Oswald", 53));

var actualException = Assert.IsType<NotExplicitlyMockedException>(actual);
Assert.Equal("'StringProperty' in 'demoDependency' is not explicitly mocked.", actualException.Message);
Assert.Equal("Greeting", actualException.MemberName);
Assert.Equal("MethodDemoClass", actualException.InstanceName);
```

## Mocking multiple values using fluent notation 

When configuring a mock, multiple methods and parameters can be configured using fluent notation.

__config__: The `MockConfig` object for the [Demo class](Sample.md#method-demo-class).<br/>

```csharp
config
    .Greeting("Oswald is 53 years old.")
    .GetAgeAsync(53)
    .SetAge()
    .TryGetAge(true, 53);
```

## Mocking the same method multiple times 

When configuring a mock, setting the same method multiple times will overwrite the previous values.
In order to return a sequence of values use the [return values](ReturnSimpleValues.md#mocking-using-return-values) argument.

__config__: <br/>

```csharp
config
    .Greeting("Oswald is 53 years old.")
    .Greeting("Bingo is 49 years old.")
    .Greeting(new Exception("This will be the end result"));
```

## Extension methods properties and indexers 

It is not possible to mock extension members directly.
Instead, mock the actual members called by the extensions.

While it can be hard to figure out exactly which methods is called by an extension method, it does make for a simpler mock.
As an example see the ILogger interface

```csharp
var mock = Mock.MethodDemoClass(config => config
    .TryGetAge(true, 53)
);

mock.GetMultipleAges(["Oswald", "Bingo"]);
```

Please be aware that the actual extension method is called and any unintended side effect will come into effect.

