<!-- This file was auto-generated by SweetDoky -->
# General setup and initialization 

Add [Sweet mock](https://www.nuget.org/packages/sweetmock) to your test project via the NuGet CLI.
```csharpInstall-Package SweetMock```
Or use your nuget package manager of choice.

__config__: Unless otherwise specified the `config` parameter is the configuration object for [Demo class](References.md#method-demo-class).<br/>

This class leverages SweetMock attributes and configuration to help developers create fixtures and mocks for their unit test cases.
It demonstrates essential setup tasks and handles scenarios such as uninitialized mocks and fluent configuration.

## Defining mocks and fixtures 

To create a mock or fixture, use the `[Mock<...>]` or `[Fixture<...>]`. SweetMock will scan these and generate the necessary code.

Mocks and fixtures can be added multiple times in different files but will only be created once. It is recommended to specify the mock or fixture on each test-class since this makes it more clear which elements are used where.

```csharp
[Mock<IDemoDependency>]
[Fixture<DemoService>]
public class DefiningMocksAndFixtures
{
    [Fact]
    public void AttributeOnMethod()
    {
        /*
         * Your unit testing code here
         */
    }
}
```

Mocks and fixture attributes can also be added to assemblies, methods, properties, and a lot of other targets. But generally adding them to test classes is recommended.

There are some limitations to which types of targets can be used for mock and fixture. For more details see [Advanced Mocking](AdvancedMocking.md)

## Comparing mock and fixture 

SweetMock supports two different operational modes.
- `Mock`: The more traditional way of mocking where each dependency is created separately and used when creating the system under test.
- `Fixture`: A more modern way of mocking where the system under test is specified and all dependencies are mocked automatically.

The following code compares the use of a fixture with manually created mocks when setting up a System Under Test (SUT).
Both methods initialize the DemoService class with a collection of mocked components, and the resulting SUT is functionally identical.

The fixture approach has added benefits when it comes to asserting calls across dependencies. See 

```csharp
// Arrange using fixture
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency.StringProperty("Initial value");
});
var sutUsingFixture = fixture.CreateDemoService();

// Arrange using mock
var mockTimeProvider = TimeProvider.System;
var mockHttpClient = Mock.HttpClient();
var mockOptions = Mock.IOptions<DemoServiceConfig>();
var mockDemoDependency = Mock.IDemoDependency(config => config.StringProperty("Initial value"));
var mockLogger = Mock.ILogger<DemoService>();
var sutUsingMock = new DemoService(mockTimeProvider, mockHttpClient, mockOptions, mockDemoDependency, mockLogger);
```

 > [!NOTE]
 > The fixture-based approach provides a streamlined configuration for creating the SUT with required
 > dependencies pre-initialized. This approach greatly reduces boilerplate code.

The mock-based approach offers fine-grained control by manually creating and configuring individual mocks
for each dependency. While this approach allows for changing dependencies upfront, the same effect can be done using [Specifying specific dependencies](AdvancedMocking.md#specifying-specific-dependencies).

 > [!TIP]
 > In the example some of the build in mocks are using. For more details on them see [Buildin mock for i logger](BuildinMocks.md#buildin-mock-for-i-logger).

## Creating and configuring a fixture 

Fixtures simplify creating all the mocks required for a service.
For each dependency a configuration object is created allowing configuration of the mock.
The mocks can be configured by calling the configuration object with the dependencies name.

```csharp
// Arrange
var fixture = Fixture.DemoService(config =>
{
    config.demoDependency
        .StringProperty("Initial value");
});
var sut = fixture.CreateDemoService();

// ACT
var actual = sut.GetStringProperty();

// Assert
Assert.Equal("Initial value", actual);
```

The configuration of the fixture can also be access by calling fixture.Config allowing for modifying the configuration after creating the sut.
It is recommended to keep this to a minimum since it makes the configuration harder to read.

## Uninitialized mocks throw exceptions 

Calling a method that is not mocked will result in a `NotExplicitlyMockedException` exception being thrown.
The exception details which method on which mock was called.

```csharp
var mock = Mock.MethodDemoClass(config => { });

var actual = Record.Exception(() => mock.Greeting("Oswald", 53));

var actualException = Assert.IsType<NotExplicitlyMockedException>(actual);
Assert.Equal("'StringProperty' in 'demoDependency' is not explicitly mocked.", actualException.Message);
Assert.Equal("Greeting", actualException.MemberName);
Assert.Equal("MethodDemoClass", actualException.InstanceName);
```

 > [!NOTE]
 > Please note that the `NotExplicitlyMockedException` exception should not be caught as shown in the example.

## Mocking multiple values using fluent notation 

When configuring a mock, multiple methods and parameters can be configured using fluent notation.

```csharp
config
    .Greeting("Oswald is 53 years old.")
    .GetAgeAsync(53)
    .SetAge()
    .TryGetAge(true, 53);
```

 > [!IMPORTANT]
 > Setting the same method or property multiple times will overwrite the previous values. See 

## Mocking the same method multiple times 

When configuring a mock, setting the same method multiple times will overwrite the previous values.
To return a sequence of values, use the [return values](ReturnSimpleValues.md#mocking-using-return-values) argument.

```csharp
config
    .Greeting("Oswald is 53 years old.")
    .Greeting("Bingo is 49 years old.")
    .Greeting(new Exception("This will be the end result"));
```

 > [!NOTE]
 > For more advanced scenarios, please see [Mocking complex behavior using call](AdvancedMocking.md#mocking-complex-behavior-using-call).

## Extension methods properties and indexers 

It is not possible to mock extension members directly.
Instead, mock the actual members called by the extensions.

While it can be hard to figure out exactly which methods is called by an extension method, it does make for a simpler mock.
As an example, see the ILogger interface

```csharp
var mock = Mock.MethodDemoClass(config => config
    .TryGetAge(true, 53)
);

mock.GetMultipleAges(["Oswald", "Bingo"]);
```

 > [!IMPORTANT]
 > Please be aware that the actual extension method is called and any unintended side effect will come into effect.

