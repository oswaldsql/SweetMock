// This file was auto-generated by SweetMock 0.9.31.0 at 2025-10-01 06:53:47Z
// Changes to this file may be lost when the code is regenerated.

#nullable enable

using global::System.Linq;
using global::System;
using global::SweetMock;

namespace System.Net.Http{
    using Text.Json;
    using Threading;
    using Threading.Tasks;

    /// <summary>
    ///    Mock implementation of <see cref="global::System.Net.Http.HttpClient">HttpClient</see>.
    ///    Should only be used for testing purposes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SweetMockVersion}}")]
    internal class MockOf_HttpClient() : global::SweetMock.MockBase<HttpClient>(new EClient(new())){
        public class EClient(MockHandler handler) : HttpClient(handler)
        {
            public MockHandler Handler => handler;
        }
    }

    internal class MockHandler() : HttpMessageHandler
    {
        internal Func<HttpRequestMessage, CancellationToken, Task<HttpResponseMessage>> CallBack { get; set; } = (message, _) => Task.FromResult(message.ReplyNotFound());
        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) => this.CallBack.Invoke(request, cancellationToken);
    }

    public static class MockOf_HttpClientConfig_Extensions
    {
        public static void SendAsync(this MockOf_HttpClient.MockConfig config, Func<HttpRequestMessage, CancellationToken, Task<HttpResponseMessage>> callBack)
        {
            if (config.Value is not MockOf_HttpClient.EClient client)
            {
                throw new AccessViolationException();
            }

            client.Handler.CallBack = callBack;
        }

        public static void Send(this MockOf_HttpClient.MockConfig config, Func<HttpRequestMessage, HttpResponseMessage> callBack)
        {
            if (config.Value is not MockOf_HttpClient.EClient client)
            {
                throw new AccessViolationException();
            }

            client.Handler.CallBack = (message, token) => Task.FromResult(callBack(message));
        }

        public static HttpResponseMessage Reply(this HttpRequestMessage request, HttpStatusCode statusCode) => new(statusCode) { RequestMessage = request, Version = request.Version};

        public static HttpResponseMessage ReplyOk(this HttpRequestMessage request) => request.Reply(HttpStatusCode.OK);
        public static HttpResponseMessage ReplyCreated(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Created);
        public static HttpResponseMessage ReplyNoContent(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NoContent);
        public static HttpResponseMessage ReplyMovedPermanently(this HttpRequestMessage request, string uri)
        {
            var result = request.Reply(HttpStatusCode.MovedPermanently);
            result.Headers.Location = new Uri(uri);
            return result;
        }
        public static HttpResponseMessage ReplyMovedPermanently(this HttpRequestMessage request, Uri uri)
        {
            var result = request.Reply(HttpStatusCode.MovedPermanently);
            result.Headers.Location = uri;
            return result;
        }

        public static HttpResponseMessage ReplyFound(this HttpRequestMessage request, string uri)
        {
            var result = request.Reply(HttpStatusCode.Found);
            result.Headers.Location = new Uri(uri);
            return result;
        }
        public static HttpResponseMessage ReplyFound(this HttpRequestMessage request, Uri uri)
        {
            var result = request.Reply(HttpStatusCode.Found);
            result.Headers.Location = uri;
            return result;
        }


        public static HttpResponseMessage ReplyNotModified(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NotModified);
        public static HttpResponseMessage ReplyBadRequest(this HttpRequestMessage request) => request.Reply(HttpStatusCode.BadRequest);
        public static HttpResponseMessage ReplyUnauthorized(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Unauthorized);
        public static HttpResponseMessage ReplyForbidden(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Forbidden);
        public static HttpResponseMessage ReplyNotFound(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NotFound);
        public static HttpResponseMessage ReplyMethodNotAllowed(this HttpRequestMessage request) => request.Reply(HttpStatusCode.MethodNotAllowed);
        public static HttpResponseMessage ReplyConflict(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Conflict);
        public static HttpResponseMessage ReplyUnsupportedMediaType(this HttpRequestMessage request) => request.Reply(HttpStatusCode.UnsupportedMediaType);
        public static HttpResponseMessage ReplyTooManyRequests(this HttpRequestMessage request) => request.Reply(HttpStatusCode.TooManyRequests);
        public static HttpResponseMessage ReplyInternalServerError(this HttpRequestMessage request) => request.Reply(HttpStatusCode.InternalServerError);
        public static HttpResponseMessage ReplyBadGateway(this HttpRequestMessage request) => request.Reply(HttpStatusCode.BadGateway);
        public static HttpResponseMessage ReplyServiceUnavailable(this HttpRequestMessage request) => request.Reply(HttpStatusCode.ServiceUnavailable);
        public static HttpResponseMessage ReplyGatewayTimeout(this HttpRequestMessage request) => request.Reply(HttpStatusCode.GatewayTimeout);

        public static HttpResponseMessage WithContent(this HttpResponseMessage response, HttpContent content, string contentType)
        {
            response.Content = content;
            response.Content.Headers.ContentType = new(contentType);
            return response;
        }

        public static HttpResponseMessage WithHtmlContent(this HttpResponseMessage response, string html)
            => response.WithContent(new StringContent(html), "text/html");

        public static HttpResponseMessage WithJsonContent(this HttpResponseMessage response, string json)
            => response.WithContent(new StringContent(json), "application/json");

        public static HttpResponseMessage WithJsonContent(this HttpResponseMessage response, object jsonSource)
        {
            var json = JsonSerializer.Serialize(jsonSource, JsonSerializerOptions.Web);
            return response.WithContent(new StringContent(json), "application/json");
        }

        public static HttpResponseMessage WithHeader(this HttpResponseMessage response, string headerName, string headerValue)
        {
            response.Headers.Add(headerName, headerValue);
            return response;
        }
    }
}
