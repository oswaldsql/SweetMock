// This file was auto-generated by SweetMock {{SweetMockVersion}}
// Changes to this file may be lost when the code is regenerated.

// ReSharper disable RedundantNameQualifier
// ReSharper disable RedundantNullableDirective
// ReSharper disable RedundantNameQualifier
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantCast
// ReSharper disable RedundantLambdaParameterType
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable NotAccessedPositionalProperty.Global
// ReSharper disable UnusedType.Global
// ReSharper disable ArrangeObjectCreationWhenTypeNotEvident
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Local
// ReSharper disable ArrangeObjectCreationWhenTypeEvident
// ReSharper disable ArrangeObjectCreationWhenTypeNotEvident
// ReSharper disable UnusedMethodReturnValue.Global
// ReSharper disable ConvertIfStatementToReturnStatement

#nullable enable

using global::SweetMock;
using global::System.Linq;
using global::System.Threading;
using global::System.Threading.Tasks;


namespace System.Net.Http;

using Text.Json;

/// <summary>
///    Mock implementation of <see cref="global::System.Net.Http.HttpClient">HttpClient</see>.
///    Should only be used for testing purposes.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("SweetMock", "{{SweetMockVersion}}")]
internal partial class MockOf_HttpClient : HttpClient
{
    private const string ContainerName = "global::System.Net.Http.HttpClient";

    #region Configuration

    /// <summary>
    ///    Configuration class for the mock.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("SweetMock", "{{SweetMockVersion}}")]
    internal partial class MockConfig
    {
        private readonly MockOf_HttpClient target;

        /// <summary>
        ///    Initializes the configuration for <see cref="global::System.Net.Http.HttpClient">HttpClient</see> instance of the MockConfig class
        /// </summary>
        /// <param name="target">The target mock class.</param>
        /// <param name="config">Optional configuration method.</param>
        public MockConfig(MockOf_HttpClient target, System.Action<MockConfig>? config = null)
        {
            this.target = target;
            config?.Invoke(this);
        }
    }
    #endregion

    #region Logging
    private readonly global::SweetMock.CallLog _sweetMockCallLog = new global::SweetMock.CallLog();
    private void _log(global::SweetMock.ArgumentBase argument) => this._sweetMockCallLog.Add(argument);

    internal partial class MockConfig
    {
        internal MockConfig GetCallLogs(out HttpClient_Logs callLog)
        {
            callLog = new HttpClient_Logs(this.target._sweetMockCallLog, this.target._sweetMockInstanceName);
            return this;
        }
    }
    #endregion

    #region Constructors
    private global::SweetMock.MockOptions? _sweetMockOptions { get; set; }
    private string _sweetMockInstanceName { get; set; } = "";

    public record HttpClient_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature
    ) : ArgumentBase(ContainerName, "HttpClient", MethodSignature, InstanceName);

    protected internal MockOf_HttpClient(System.Action<MockConfig>? config = null, global::SweetMock.MockOptions? options = null) : this(new MockHandler())
    {
        this._sweetMockOptions = options ?? global::SweetMock.MockOptions.Default;
        this._sweetMockCallLog = this._sweetMockOptions.Logger ?? this._sweetMockCallLog;
        this._sweetMockInstanceName = this._sweetMockOptions.InstanceName ?? "HttpClient";
        this._log(new HttpClient_Arguments(this._sweetMockInstanceName, "HttpClient"));
        new MockConfig(this, config);
    }

    private MockOf_HttpClient(MockHandler handler) : base(handler) =>
        handler._SendAsync = this.SendAsync;

    #endregion

    #region Method : Dispose

    public record Dispose_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::System.Boolean? disposing = null
    ) : ArgumentBase(ContainerName, "Dispose", MethodSignature, InstanceName);

    protected override void Dispose(bool disposing)
    {
        this._log(new Dispose_Arguments(this._sweetMockInstanceName, "Dispose(System.Boolean)", disposing: disposing));
        if (this._Dispose is null)
        {
            throw new global::SweetMock.NotExplicitlyMockedException("Dispose", this._sweetMockInstanceName);
        }

        this._Dispose.Invoke(disposing);
    }

    private MockConfig.DelegateFor_Dispose? _Dispose { get; set; } = _ => { };

    internal partial class MockConfig
    {
        /// <summary>
        ///    Delegate for mocking calls to <see cref="global::System.Net.Http.HttpClient.Dispose(System.Boolean)">HttpClient.Dispose(bool)</see>.
        /// </summary>
        public delegate void DelegateFor_Dispose(bool disposing);

        /// <summary>
        ///    Configures the mock to execute the specified action when calling <see cref="global::System.Net.Http.HttpClient.Dispose(System.Boolean)">HttpClient.Dispose(bool)</see>.
        /// </summary>
        /// <param name="call">The action or function to execute when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Dispose(DelegateFor_Dispose call)
        {
            this.target._Dispose = call;
            return this;
        }

        /// <summary>
        ///    Configures the mock to accept any call to methods not returning values.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.Dispose(System.Boolean)">HttpClient.Dispose(bool)</see>
        /// </summary>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Dispose()
        {
            this.Dispose(call: (DelegateFor_Dispose)((bool _) => { }));
            return this;
        }

        /// <summary>
        ///    Configures the mock to throw the specified exception when the method is called.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.Dispose(System.Boolean)">HttpClient.Dispose(bool)</see>
        /// </summary>
        /// <param name="throws">The exception to be thrown when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Dispose(System.Exception throws)
        {
            this.Dispose(call: (DelegateFor_Dispose)((bool _) => throw throws));
            return this;
        }
    }
    #endregion

    #region Method : Send

    public record Send_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::System.Net.Http.HttpRequestMessage? request = null,
        global::System.Threading.CancellationToken? cancellationToken = null
    ) : ArgumentBase(ContainerName, "Send", MethodSignature, InstanceName);

    public override System.Net.Http.HttpResponseMessage Send(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)
    {
        this._log(new Send_Arguments(this._sweetMockInstanceName, "Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)", request: request, cancellationToken: cancellationToken));
        if (this._SendAsync is null)
        {
            throw new global::SweetMock.NotExplicitlyMockedException("Send", this._sweetMockInstanceName);
        }

        return this._SendAsync.Invoke(request, cancellationToken).Result;
    }

    internal partial class MockConfig
    {
        /// <summary>
        ///    Delegate for mocking calls to <see cref="global::System.Net.Http.HttpClient.Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.Send(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        public delegate System.Net.Http.HttpResponseMessage DelegateFor_Send(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        ///    Configures the mock to execute the specified action when calling <see cref="global::System.Net.Http.HttpClient.Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.Send(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        /// <param name="call">The action or function to execute when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Send(DelegateFor_Send call)
        {
            this.SendAsync(call: (request, token) => Task.FromResult(call(request, token)));
            return this;
        }

        public MockConfig Send(System.Func<System.Net.Http.HttpRequestMessage, System.Net.Http.HttpResponseMessage> call)
        {
            this.SendAsync(call: (request, _) => Task.FromResult(call(request)));
            return this;
        }

        /// <summary>
        ///    Configures the mock to return a specific value, regardless of the provided arguments.
        ///    Use this to quickly define a fixed return result for <see cref="global::System.Net.Http.HttpClient.Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.Send(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        /// <param name="returns">The fixed value that should be returned by the mock.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Send(System.Net.Http.HttpResponseMessage returns)
        {
            this.Send(call: (DelegateFor_Send)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) => returns));
            return this;
        }

        /// <summary>
        ///    Configures the mock to return one of the specific values disregarding the arguments.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.Send(HttpRequestMessage, CancellationToken)</see>
        /// </summary>
        /// <param name="returnValues">The values that should be returned in order. If the values are depleted <see cref="System.InvalidOperationException"/>  is thrown.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Send(System.Collections.Generic.IEnumerable<System.Net.Http.HttpResponseMessage> returnValues)
        {
            var Send1_Values = returnValues.GetEnumerator();
            this.Send(call: (DelegateFor_Send)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) =>
                    {
                        if (Send1_Values.MoveNext())
                        {
                            return Send1_Values.Current;
                        }

                        Send1_Values.Dispose();
                        throw new SweetMock.NotExplicitlyMockedException("Send", this.target._sweetMockInstanceName);
                    }
                ));
            return this;
        }

        /// <summary>
        ///    Configures the mock to throw the specified exception when the method is called.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.Send(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.Send(HttpRequestMessage, CancellationToken)</see>
        /// </summary>
        /// <param name="throws">The exception to be thrown when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Send(System.Exception throws)
        {
            this.Send(call: (DelegateFor_Send)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) => throw throws));
            return this;
        }
    }
    #endregion

    #region Method : SendAsync
    public record SendAsync_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::System.Net.Http.HttpRequestMessage? request = null,
        global::System.Threading.CancellationToken? cancellationToken = null
    ) : ArgumentBase(ContainerName, "SendAsync", MethodSignature, InstanceName);

    public override System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage> SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)
    {
        this._log(new SendAsync_Arguments(this._sweetMockInstanceName, "SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)", request: request, cancellationToken: cancellationToken));
        if (this._SendAsync is null)
        {
            throw new global::SweetMock.NotExplicitlyMockedException("SendAsync", this._sweetMockInstanceName);
        }

        return this._SendAsync.Invoke(request, cancellationToken);
    }

    private MockConfig.DelegateFor_SendAsync _SendAsync { get; set; } = null!;

    internal partial class MockConfig
    {
        /// <summary>
        ///    Delegate for mocking calls to <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        public delegate System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage> DelegateFor_SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        ///    Configures the mock to execute the specified action when calling <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        /// <param name="call">The action or function to execute when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SendAsync(DelegateFor_SendAsync call)
        {
            this.target._SendAsync = call;
            return this;
        }

        /// <summary>
        ///    Configures the mock to return a specific value, regardless of the provided arguments.
        ///    Use this to quickly define a fixed return result for <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        /// <param name="returns">The fixed value that should be returned by the mock.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SendAsync(System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage> returns)
        {
            this.SendAsync(call: (DelegateFor_SendAsync)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) => returns));
            return this;
        }

        /// <summary>
        ///    Configures the mock to return a specific value as a <see cref="System.Threading.Tasks.Task{T}"/>, regardless of the provided arguments.
        ///    Use this to quickly define a fixed return result for <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>.
        /// </summary>
        /// <param name="returnAsTasks">The fixed <see cref="global::System.Net.Http.HttpResponseMessage">HttpResponseMessage</see> that should be returned by the mock wrapped in a <see cref="System.Threading.Tasks.Task{T}"/></param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SendAsync(System.Net.Http.HttpResponseMessage returnAsTasks)
        {
            this.SendAsync(call: (System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) => System.Threading.Tasks.Task.FromResult(returnAsTasks));
            return this;
        }

        /// <summary>
        ///    Configures the mock to return one of the specific values disregarding the arguments.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>
        /// </summary>
        /// <param name="returnValues">The values that should be returned in order. If the values are depleted <see cref="System.InvalidOperationException"/>  is thrown.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SendAsync(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<System.Net.Http.HttpResponseMessage>> returnValues)
        {
            var SendAsync1_Values = returnValues.GetEnumerator();
            this.SendAsync(call: (DelegateFor_SendAsync)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) =>
                    {
                        if (SendAsync1_Values.MoveNext())
                        {
                            return SendAsync1_Values.Current;
                        }
                        SendAsync1_Values.Dispose();
                        throw new SweetMock.NotExplicitlyMockedException("SendAsync", "HttpClient");
                    }
                ));
            return this;
        }

        /// <summary>
        ///    Configures the mock to throw the specified exception when the method is called.
        ///    Configures <see cref="global::System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage, System.Threading.CancellationToken)">HttpClient.SendAsync(HttpRequestMessage, CancellationToken)</see>
        /// </summary>
        /// <param name="throws">The exception to be thrown when the method is called.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SendAsync(System.Exception throws)
        {
            this.SendAsync(call: (DelegateFor_SendAsync)((System.Net.Http.HttpRequestMessage _, System.Threading.CancellationToken _) => throw throws));
            return this;
        }
    }
    #endregion

    internal class MockHandler : HttpMessageHandler
    {
        internal System.Func<HttpRequestMessage, CancellationToken, Task<HttpResponseMessage>>? _SendAsync;

        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) =>
            this._SendAsync!(request, cancellationToken);
    }
}

internal partial class MockOf_HttpClient{
    [System.CodeDom.Compiler.GeneratedCode("SweetMock", "{{SweetMockVersion}}")]
    internal class HttpClient_Logs(CallLog log, string? instanceName = null) : global::SweetMock.FixtureLog_Base(log, instanceName){
        public System.Collections.Generic.IEnumerable<MockOf_HttpClient.HttpClient_Arguments> HttpClient(System.Func<MockOf_HttpClient.HttpClient_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_HttpClient.HttpClient_Arguments>().Where(filter ?? (_ => true));

        public System.Collections.Generic.IEnumerable<MockOf_HttpClient.Dispose_Arguments> Dispose(System.Func<MockOf_HttpClient.Dispose_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_HttpClient.Dispose_Arguments>().Where(filter ?? (_ => true));

        public System.Collections.Generic.IEnumerable<MockOf_HttpClient.Send_Arguments> Send(System.Func<MockOf_HttpClient.Send_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_HttpClient.Send_Arguments>().Where(filter ?? (_ => true));

        public System.Collections.Generic.IEnumerable<MockOf_HttpClient.SendAsync_Arguments> SendAsync(System.Func<MockOf_HttpClient.SendAsync_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_HttpClient.SendAsync_Arguments>().Where(filter ?? (_ => true));
    }
}

internal static class MockOf_HttpClient_LogExtensions
{
    public static MockOf_HttpClient.HttpClient_Logs HttpClient(this CallLog all) => new(all);

    public static System.Collections.Generic.IEnumerable<MockOf_HttpClient.Send_Arguments> Send(this CallLog all, System.Func<MockOf_HttpClient.Send_Arguments, bool>? filter = null) =>
        all.HttpClient().Send(filter);

    public static System.Collections.Generic.IEnumerable<MockOf_HttpClient.SendAsync_Arguments> SendAsync(this CallLog all, System.Func<MockOf_HttpClient.SendAsync_Arguments, bool>? filter = null) =>
        all.HttpClient().SendAsync(filter);
}

public static class HttpClient_TestExtensions
{
    public static HttpResponseMessage Reply(this HttpRequestMessage request, System.Net.HttpStatusCode statusCode) => new(statusCode) { RequestMessage = request, Version = request.Version };

    public static HttpResponseMessage ReplyOk(this HttpRequestMessage request) => request.Reply(HttpStatusCode.OK);
    public static HttpResponseMessage ReplyCreated(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Created);
    public static HttpResponseMessage ReplyNoContent(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NoContent);

    public static HttpResponseMessage ReplyMovedPermanently(this HttpRequestMessage request, string uri)
    {
        var result = request.Reply(HttpStatusCode.MovedPermanently);
        result.Headers.Location = new Uri(uri);
        return result;
    }

    public static HttpResponseMessage ReplyMovedPermanently(this HttpRequestMessage request, Uri uri)
    {
        var result = request.Reply(HttpStatusCode.MovedPermanently);
        result.Headers.Location = uri;
        return result;
    }

    public static HttpResponseMessage ReplyFound(this HttpRequestMessage request, string uri)
    {
        var result = request.Reply(System.Net.HttpStatusCode.Found);
        result.Headers.Location = new Uri(uri);
        return result;
    }

    public static HttpResponseMessage ReplyFound(this HttpRequestMessage request, Uri uri)
    {
        var result = request.Reply(HttpStatusCode.Found);
        result.Headers.Location = uri;
        return result;
    }


    public static HttpResponseMessage ReplyNotModified(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NotModified);
    public static HttpResponseMessage ReplyBadRequest(this HttpRequestMessage request) => request.Reply(HttpStatusCode.BadRequest);

    /// <summary>
    /// For information about what parameters to use refere to <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/WWW-Authenticate">Mozilla documentation</a>
    /// </summary>
    /// <param name="request">The request to use as a source of the response.</param>
    /// <param name="scheme">The authentication schema.</param>
    /// <param name="parameter">The authentication parameters</param>
    /// <returns>A response message.</returns>
    public static HttpResponseMessage ReplyUnauthorized(this HttpRequestMessage request, string scheme, string? parameter = null)
    {
        var result = request.Reply(HttpStatusCode.Unauthorized);
        result.Headers.WwwAuthenticate.Add(new(scheme, parameter));
        return result;
    }

    public static HttpResponseMessage ReplyForbidden(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Forbidden);
    public static HttpResponseMessage ReplyNotFound(this HttpRequestMessage request) => request.Reply(HttpStatusCode.NotFound);
    public static HttpResponseMessage ReplyMethodNotAllowed(this HttpRequestMessage request) => request.Reply(HttpStatusCode.MethodNotAllowed);
    public static HttpResponseMessage ReplyConflict(this HttpRequestMessage request) => request.Reply(HttpStatusCode.Conflict);
    public static HttpResponseMessage ReplyUnsupportedMediaType(this HttpRequestMessage request) => request.Reply(HttpStatusCode.UnsupportedMediaType);
    public static HttpResponseMessage ReplyTooManyRequests(this HttpRequestMessage request) => request.Reply(HttpStatusCode.TooManyRequests);
    public static HttpResponseMessage ReplyInternalServerError(this HttpRequestMessage request) => request.Reply(HttpStatusCode.InternalServerError);
    public static HttpResponseMessage ReplyBadGateway(this HttpRequestMessage request) => request.Reply(HttpStatusCode.BadGateway);
    public static HttpResponseMessage ReplyServiceUnavailable(this HttpRequestMessage request) => request.Reply(HttpStatusCode.ServiceUnavailable);
    public static HttpResponseMessage ReplyGatewayTimeout(this HttpRequestMessage request) => request.Reply(HttpStatusCode.GatewayTimeout);

    public static HttpResponseMessage WithContent(this HttpResponseMessage response, HttpContent content, string contentType)
    {
        response.Content = content;
        response.Content.Headers.ContentType = new(contentType);
        return response;
    }

    public static HttpResponseMessage WithHtmlContent(this HttpResponseMessage response, string html)
        => response.WithContent(new StringContent(html), "text/html");

    public static HttpResponseMessage WithJsonContent(this HttpResponseMessage response, string json)
        => response.WithContent(new StringContent(json), "application/json");

    public static HttpResponseMessage WithStringContent(this HttpResponseMessage response, string text)
        => response.WithContent(new StringContent(text), "application/text");

    public static HttpResponseMessage WithJsonContent(this HttpResponseMessage response, object jsonSource)
    {
        var json = JsonSerializer.Serialize(jsonSource, JsonSerializerOptions.Web);
        return response.WithContent(new StringContent(json), "application/json");
    }

    public static HttpResponseMessage WithByteArrayContent(this HttpResponseMessage response, byte[] byteSource) =>
        response.WithContent(new ByteArrayContent(byteSource), "application/octet-stream");

    public static HttpResponseMessage WithHeader(this HttpResponseMessage response, string headerName, string headerValue)
    {
        response.Headers.Add(headerName, headerValue);
        return response;
    }
}
