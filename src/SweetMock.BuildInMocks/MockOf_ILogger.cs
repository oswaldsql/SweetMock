// This file was auto-generated by SweetMock {{SweetMockVersion}}
// Changes to this file may be lost when the code is regenerated.

// ReSharper disable RedundantNameQualifier
// ReSharper disable RedundantNullableDirective
// ReSharper disable RedundantNameQualifier
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantCast
// ReSharper disable RedundantLambdaParameterType
// ReSharper disable UnusedMember.Global
// ReSharper disable MemberCanBePrivate.Global
// ReSharper disable NotAccessedPositionalProperty.Global
// ReSharper disable UnusedType.Global
// ReSharper disable ArrangeObjectCreationWhenTypeNotEvident
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Local
// ReSharper disable ArrangeObjectCreationWhenTypeEvident
// ReSharper disable ArrangeObjectCreationWhenTypeNotEvident
// ReSharper disable UnusedMethodReturnValue.Global
// ReSharper disable ConvertIfStatementToReturnStatement



#nullable enable

using global::SweetMock;
using System.Linq;

namespace Microsoft.Extensions.Logging;

/// <summary>
///    Mock implementation of <see cref="global::Microsoft.Extensions.Logging.ILogger{TCategoryName}">ILogger&lt;TCategoryName&gt;</see>.
///    Should only be used for testing purposes.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SweetMockVersion}}")]
internal partial class MockOf_ILogger<TCategoryName> : ILogger<TCategoryName>{
    private const string _containerName = "global::Microsoft.Extensions.Logging.ILogger<out TCategoryName>";
    #region Configuration
    /// <summary>
    ///    Configuration class for the mock.
    /// </summary>
    internal partial class MockConfig{
        private readonly MockOf_ILogger<TCategoryName> target;
        /// <summary>
        ///    Initializes the configuration for <see cref="global::Microsoft.Extensions.Logging.ILogger{TCategoryName}">ILogger&lt;TCategoryName&gt;</see> instance of the MockConfig class
        /// </summary>
        /// <param name="target">The target mock class.</param>
        /// <param name="config">Optional configuration method.</param>
        public MockConfig(MockOf_ILogger<TCategoryName> target, System.Action<MockConfig>? config = null){
            this.target = target;
            config?.Invoke(this);
        }
    }
    #endregion

    #region Logging
    private readonly global::SweetMock.CallLog _sweetMockCallLog = new global::SweetMock.CallLog();
    private void _log(global::SweetMock.ArgumentBase argument) =>
        this._sweetMockCallLog.Add(argument);

    internal partial class MockConfig{
        internal MockConfig GetCallLogs(out ILogger_Logs callLog){
            callLog = new ILogger_Logs(this.target._sweetMockCallLog, this.target._sweetMockInstanceName);
            return this;
        }
    }
    #endregion

    #region Constructors
    private global::SweetMock.MockOptions? _sweetMockOptions {get;set;}
    private string _sweetMockInstanceName {get; set;} = "";

    public record ILogger_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature
    ) : ArgumentBase(_containerName, "ILogger", MethodSignature, InstanceName);

    protected internal MockOf_ILogger(System.Action<MockConfig>? config = null, global::SweetMock.MockOptions? options = null){
        this._sweetMockOptions = options ?? global::SweetMock.MockOptions.Default;
        this._sweetMockCallLog = options?.Logger ?? this._sweetMockCallLog;
        this._sweetMockInstanceName = this._sweetMockOptions.InstanceName ?? "ILogger";
        this._log(new ILogger_Arguments(this._sweetMockInstanceName, "ILogger"));
        new MockConfig(this, config);
    }
    #endregion

    #region Method : Log
    public record Log_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::System.String message,
        global::Microsoft.Extensions.Logging.LogLevel? logLevel = null, global::Microsoft.Extensions.Logging.EventId? eventId = null, global::System.Object? state = null, global::System.Exception? exception = null, global::System.Object? formatter = null
    ) : ArgumentBase(_containerName, "Log", MethodSignature, InstanceName);

    void global::Microsoft.Extensions.Logging.ILogger.Log<TState>(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter){
        var message = formatter(state, exception);
        this._log(new Log_Arguments(this._sweetMockInstanceName, "Log<TState>(Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, TState, System.Exception, System.Func<TState, System.Exception, System.String>)", message : message, logLevel : logLevel, eventId : eventId, state : state, exception : exception, formatter : formatter));
    }
    #endregion

    #region Method : IsEnabled
    public record IsEnabled_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::Microsoft.Extensions.Logging.LogLevel? logLevel = null
    ) : ArgumentBase(_containerName, "IsEnabled", MethodSignature, InstanceName);

    bool global::Microsoft.Extensions.Logging.ILogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel logLevel){
        this._log(new IsEnabled_Arguments(this._sweetMockInstanceName, "IsEnabled(Microsoft.Extensions.Logging.LogLevel)", logLevel : logLevel));
        return this._logLevel >= logLevel;
    }

    private global::Microsoft.Extensions.Logging.LogLevel _logLevel = global::Microsoft.Extensions.Logging.LogLevel.Information;

    internal partial class MockConfig{
        /// <summary>
        ///    Configures the to write to the log when the log level is equal or above the specified level. Default value is <see cref="Microsoft.Extensions.Logging.LogLevel.Information">Information</see>. <see cref="global::Microsoft.Extensions.Logging.ILogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">ILogger.IsEnabled(LogLevel)</see>.
        /// </summary>
        /// <param name="logLevel">The level to log to.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig SetLogLevel(global::Microsoft.Extensions.Logging.LogLevel logLevel = global::Microsoft.Extensions.Logging.LogLevel.Information){
            this.target._logLevel = logLevel;
            return this;
        }
    }
    #endregion

    #region Method : BeginScope
    public record BeginScope_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        global::System.Object? state = null
    ) : ArgumentBase(_containerName, "BeginScope", MethodSignature, InstanceName);

    public record EndScope_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature
    ) : ArgumentBase(_containerName, "EndScope", MethodSignature, InstanceName);

    System.IDisposable global::Microsoft.Extensions.Logging.ILogger.BeginScope<TState>(TState state){
        this._log(new BeginScope_Arguments(this._sweetMockInstanceName, "BeginScope<TState>(TState)", state : state));
        return new IDisposeWrapper(() =>
        {
            this._log(new EndScope_Arguments(this._sweetMockInstanceName, "EndScope<TState>(TState)"));
        });
    }

    public class IDisposeWrapper(global::System.Action action) : global::System.IDisposable{
        public void Dispose() => action();
    }
    #endregion

}

internal partial class MockOf_ILogger<TCategoryName>{
    internal class ILogger_Logs(CallLog log, string? instanceName = null) : global::SweetMock.FixtureLog_Base(log, instanceName){

        public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.Log_Arguments> Log(System.Func<MockOf_ILogger<TCategoryName>.Log_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_ILogger<TCategoryName>.Log_Arguments>().Where(filter ?? (_ => true));

        public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments> IsEnabled(System.Func<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments>().Where(filter ?? (_ => true));

        public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.BeginScope_Arguments> BeginScope(System.Func<MockOf_ILogger<TCategoryName>.BeginScope_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_ILogger<TCategoryName>.BeginScope_Arguments>().Where(filter ?? (_ => true));
    }
}
