// This file was auto-generated by SweetMock 0.9.36.0
// Changes to this file may be lost when the code is regenerated.

// ReSharper disable RedundantNameQualifier
// ReSharper disable RedundantNullableDirective
// ReSharper disable RedundantNameQualifier
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable InconsistentNaming

#nullable enable

using global::SweetMock;
using System.Linq;

namespace Microsoft.Extensions.Options;

/// <summary>
///    Mock implementation of <see cref="global::Microsoft.Extensions.Options.IOptions{TOptions}">IOptions&lt;TOptions&gt;</see>.
///    Should only be used for testing purposes.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("SweetMock","0.9.36.0")]
internal partial class MockOf_IOptions<TOptions> : IOptions<TOptions> where TOptions : class{
    private const string _containerName = "global::Microsoft.Extensions.Options.IOptions<out TOptions> where TOptions : class";
    #region Configuration
    /// <summary>
    ///    Configuration class for the mock.
    /// </summary>
    internal partial class MockConfig{
        private readonly MockOf_IOptions<TOptions> target;
        /// <summary>
        ///    Initializes the configuration for <see cref="global::Microsoft.Extensions.Options.IOptions{TOptions}">IOptions&lt;TOptions&gt;</see> instance of the MockConfig class
        /// </summary>
        /// <param name="target">The target mock class.</param>
        /// <param name="config">Optional configuration method.</param>
        public MockConfig(MockOf_IOptions<TOptions> target, System.Action<MockConfig>? config = null){
            this.target = target;

            try{
                var options = global::System.Activator.CreateInstance<TOptions>();
                this.Value(options);
            }
            catch{
                // ignored
            }

            config?.Invoke(this);
        }
    }
    #endregion

    #region Logging
    private global::SweetMock.CallLog _sweetMockCallLog = new global::SweetMock.CallLog();
    private void _log(global::SweetMock.ArgumentBase argument) =>
        this._sweetMockCallLog.Add(argument);

    internal partial class MockConfig{
        internal MockConfig GetCallLogs(out IOptions_Logs callLog){
            callLog = new IOptions_Logs(this.target._sweetMockCallLog, this.target._sweetMockInstanceName);
            return this;
        }
    }
    #endregion

    #region Constructors
    global::SweetMock.MockOptions? _sweetMockOptions {get;set;}
    string _sweetMockInstanceName {get; set;} = "";

    public record IOptions_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature
    ) : ArgumentBase(_containerName, "IOptions", MethodSignature, InstanceName);

    internal protected MockOf_IOptions(System.Action<MockConfig>? config = null, global::SweetMock.MockOptions? options = null){
        this._sweetMockOptions = options ?? global::SweetMock.MockOptions.Default;
        this._sweetMockCallLog = options?.Logger ?? this._sweetMockCallLog;
        this._sweetMockInstanceName = this._sweetMockOptions.InstanceName ?? "IOptions";
        this._log(new IOptions_Arguments(this._sweetMockInstanceName, "IOptions"));
        new MockConfig(this, config);
    }
    #endregion

    #region #region Property : Value
    public record Value_Arguments(
        global::System.String? InstanceName,
        global::System.String MethodSignature,
        object? value = null
    ) : ArgumentBase(_containerName, "Value", MethodSignature, InstanceName);

    TOptions global::Microsoft.Extensions.Options.IOptions<TOptions>.Value{
        get{
            this._log(new Value_Arguments(this._sweetMockInstanceName, "get"));
            if (this._Value_get is null){
                throw new global::SweetMock.NotExplicitlyMockedException("Value", this._sweetMockInstanceName);
            }
            return this._Value_get();
        }
    }
    private System.Func<TOptions>? _Value_get { get; set; } = null;
    private System.Action<TOptions>? _Value_set { get; set; } = null;

    internal partial class MockConfig{
        /// <summary>
        ///    Configures <see cref="global::Microsoft.Extensions.Options.IOptions{TOptions}.Value">IOptions&lt;TOptions&gt;.Value</see> by specifying methods to call when the property is accessed.
        /// </summary>
        /// <param name="get">Function to call when the property is read.</param>
        /// <returns>The updated configuration object.</returns>
        private MockConfig Value(System.Func<TOptions> get){
            this.target._Value_get = get;
            return this;
        }
        /// <summary>
        ///    Specifies a value to use for mocking the property <see cref="global::Microsoft.Extensions.Options.IOptions{TOptions}.Value">IOptions&lt;TOptions&gt;.Value</see>.
        /// </summary>
        /// <param name="value">The value to use for the initial value of the property.</param>
        /// <returns>The updated configuration object.</returns>
        public MockConfig Value(TOptions value)
        {
            global::SweetMock.ValueBox<TOptions> Value_value = new (value);
            this.Value(get : () => Value_value.Value);
            return this;
        }
    }
    #endregion

}

internal partial class MockOf_IOptions<TOptions>{
    internal class IOptions_Logs(CallLog log, string? instanceName = null) : global::SweetMock.FixtureLog_Base(log, instanceName){

        public System.Collections.Generic.IEnumerable<MockOf_IOptions<TOptions>.Value_Arguments> Value(System.Func<MockOf_IOptions<TOptions>.Value_Arguments, bool>? filter = null) =>
            this.All().OfType<MockOf_IOptions<TOptions>.Value_Arguments>().Where(filter ?? (_ => true));
    }
}
