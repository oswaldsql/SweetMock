// This file was auto-generated by SweetMock 0.9.36.0
// Changes to this file may be lost when the code is regenerated.

#nullable enable

using global::SweetMock;
using System.Linq;

namespace Microsoft.Extensions.Logging{
    /// <summary>
    ///    Mock implementation of <see cref="global::Microsoft.Extensions.Logging.ILogger{TCategoryName}">ILogger&lt;TCategoryName&gt;</see>.
    ///    Should only be used for testing purposes.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("SweetMock","0.9.36.0")]
    internal partial class MockOf_ILogger<TCategoryName> : ILogger<TCategoryName>{
        private const string _containerName = "global::Microsoft.Extensions.Logging.ILogger<out TCategoryName>";
#region Configuration
        /// <summary>
        ///    Configuration class for the mock.
        /// </summary>
        internal partial class MockConfig{
            private readonly MockOf_ILogger<TCategoryName> target;
            /// <summary>
            ///    Initializes the configuration for <see cref="global::Microsoft.Extensions.Logging.ILogger{TCategoryName}">ILogger&lt;TCategoryName&gt;</see> instance of the MockConfig class
            /// </summary>
            /// <param name="target">The target mock class.</param>
            /// <param name="config">Optional configuration method.</param>
            public MockConfig(MockOf_ILogger<TCategoryName> target, System.Action<MockConfig>? config = null){
                this.target = target;
                config?.Invoke(this);
            }
        }
#endregion

#region Logging
        private global::SweetMock.CallLog _sweetMockCallLog = new global::SweetMock.CallLog();
        private void _log(global::SweetMock.ArgumentBase argument) {_sweetMockCallLog.Calls.Add(argument);}
        internal partial class MockConfig{
            internal MockConfig GetCallLogs(out ILogger_Logs callLog){
                callLog = new ILogger_Logs(target._sweetMockCallLog, target._sweetMockInstanceName);
                return this;
            }
        }
#endregion

#region Constructors
        global::SweetMock.MockOptions? _sweetMockOptions {get;set;}
        string _sweetMockInstanceName {get; set;} = "";

        public record ILogger_Arguments(
            global::System.String? InstanceName,
            global::System.String MethodSignature
        ) : ArgumentBase(_containerName, "ILogger", MethodSignature, InstanceName);

        internal protected MockOf_ILogger(System.Action<MockConfig>? config = null, global::SweetMock.MockOptions? options = null){
            _sweetMockOptions = options ?? global::SweetMock.MockOptions.Default;
            _sweetMockCallLog = options?.Logger ?? _sweetMockCallLog;
            _sweetMockInstanceName = _sweetMockOptions.InstanceName ?? "ILogger";
            this._log(new ILogger_Arguments(_sweetMockInstanceName, "ILogger"));
            new MockConfig(this, config);
        }
#endregion

#region Method : Log
        public record Log_Arguments(
            global::System.String? InstanceName,
            global::System.String MethodSignature,
            global::System.String message,
            global::Microsoft.Extensions.Logging.LogLevel? logLevel = null, global::Microsoft.Extensions.Logging.EventId? eventId = null, global::System.Object? state = null, global::System.Exception? exception = null, global::System.Object? formatter = null
        ) : ArgumentBase(_containerName, "Log", MethodSignature, InstanceName);

        void global::Microsoft.Extensions.Logging.ILogger.Log<TState>(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter){
            var message = formatter(state, exception);
            this._log(new Log_Arguments(_sweetMockInstanceName, "Log<TState>(Microsoft.Extensions.Logging.LogLevel, Microsoft.Extensions.Logging.EventId, TState, System.Exception, System.Func<TState, System.Exception, System.String>)", message : message, logLevel : logLevel, eventId : eventId, state : state, exception : exception, formatter : formatter));
        }
#endregion

#region Method : IsEnabled
        public record IsEnabled_Arguments(
            global::System.String? InstanceName,
            global::System.String MethodSignature,
            global::Microsoft.Extensions.Logging.LogLevel? logLevel = null
        ) : ArgumentBase(_containerName, "IsEnabled", MethodSignature, InstanceName);

        bool global::Microsoft.Extensions.Logging.ILogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel logLevel){
            this._log(new IsEnabled_Arguments(_sweetMockInstanceName, "IsEnabled(Microsoft.Extensions.Logging.LogLevel)", logLevel : logLevel));
            return this._logLevel >= logLevel;
        }

        private global::Microsoft.Extensions.Logging.LogLevel _logLevel = global::Microsoft.Extensions.Logging.LogLevel.Information;

        internal partial class MockConfig{
            /// <summary>
            ///    Configures the to write to the log when the log level is equal or above the specified level. Default value is <see cref="Microsoft.Extensions.Logging.LogLevel.Information">Information</see>. <see cref="global::Microsoft.Extensions.Logging.ILogger.IsEnabled(Microsoft.Extensions.Logging.LogLevel)">ILogger.IsEnabled(LogLevel)</see>.
            /// </summary>
            /// <param name="logLevel">The level to log to.</param>
            /// <returns>The updated configuration object.</returns>
            public MockConfig SetLogLevel(global::Microsoft.Extensions.Logging.LogLevel logLevel = global::Microsoft.Extensions.Logging.LogLevel.Information){
                this.target._logLevel = logLevel;
                return this;
            }
        }
#endregion

#region Method : BeginScope
        public record BeginScope_Arguments(
            global::System.String? InstanceName,
            global::System.String MethodSignature,
            global::System.Object? state = null
        ) : ArgumentBase(_containerName, "BeginScope", MethodSignature, InstanceName);

        public record EndScope_Arguments(
            global::System.String? InstanceName,
            global::System.String MethodSignature
        ) : ArgumentBase(_containerName, "EndScope", MethodSignature, InstanceName);

        System.IDisposable? global::Microsoft.Extensions.Logging.ILogger.BeginScope<TState>(TState state){
            this._log(new BeginScope_Arguments(_sweetMockInstanceName, "BeginScope<TState>(TState)", state : state));
            return new IDisposeWrapper(() =>
            {
                this._log(new EndScope_Arguments(_sweetMockInstanceName, "EndScope<TState>(TState)"));
            });
        }

        public class IDisposeWrapper(global::System.Action action) : global::System.IDisposable{
            public void Dispose() => action();
        }
#endregion

    }

    internal partial class MockOf_ILogger<TCategoryName>{
        internal class ILogger_Logs(CallLog log, string? instanceName = null){
            public System.Collections.Generic.IEnumerable<ArgumentBase> All() =>
                log.Calls.Where(t => instanceName == null || t.InstanceName == instanceName);

            public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.Log_Arguments> Log(System.Func<MockOf_ILogger<TCategoryName>.Log_Arguments, bool>? filter = null) =>
                this.All().OfType<MockOf_ILogger<TCategoryName>.Log_Arguments>().Where(filter ?? (_ => true));

            public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments> IsEnabled(System.Func<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments, bool>? filter = null) =>
                this.All().OfType<MockOf_ILogger<TCategoryName>.IsEnabled_Arguments>().Where(filter ?? (_ => true));

            public System.Collections.Generic.IEnumerable<MockOf_ILogger<TCategoryName>.BeginScope_Arguments> BeginScope(System.Func<MockOf_ILogger<TCategoryName>.BeginScope_Arguments, bool>? filter = null) =>
                this.All().OfType<MockOf_ILogger<TCategoryName>.BeginScope_Arguments>().Where(filter ?? (_ => true));
        }
    }

}
