namespace MiniMock.Builders;

using System;
using System.Linq;
using Microsoft.CodeAnalysis;
using SweetMock;
using SweetMock.Builders;
using SweetMock.Utils;

/// <summary>
///     Provides methods to build mock classes.
/// </summary>
public class FactoryClassBuilder
{
    /// <summary>
    ///     Builds the mock classes based on the provided type symbols.
    /// </summary>
    /// <param name="typeSymbols">The type symbols to generate mocks for.</param>
    /// <param name="context">The source production context.</param>
    /// <returns>A string containing the generated mock classes.</returns>
    public string Build(MockDetails details)
    {
        var builder = new CodeBuilder();

        builder.Add($$"""
                      // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                      #nullable enable
                      namespace SweetMock {
                      ->
                      """);

        builder.Add("""
                    /// <summary>
                    ///     Factory for creating mock objects.
                    /// </summary>
                    internal static partial class Mock {
                    ->
                    """);

        if (!details.Target.Constructors.Any(t => !t.IsStatic))
            BuildFactoryMethod(details, builder);
        else
            foreach (var constructor in details.Target.Constructors.Where(Include))
                BuildFactoryMethod(details, builder, constructor);

        builder.Add("""
                    <-
                    }
                    <-
                    }
                    """);

        return builder.ToString();
    }

    /// <summary>
    ///     Determines whether the specified method symbol should be included.
    /// </summary>
    /// <param name="methodSymbol">The method symbol to check.</param>
    /// <returns><c>true</c> if the method symbol should be included; otherwise, <c>false</c>.</returns>
    private static bool Include(IMethodSymbol methodSymbol)
    {
        return methodSymbol.DeclaredAccessibility is Accessibility.Public or Accessibility.Protected && !methodSymbol.IsStatic;
    }

    /// <summary>
    ///     Builds the factory method for the specified symbol.
    /// </summary>
    /// <param name="symbol">The symbol to build the factory method for.</param>
    /// <param name="builder">The code builder.</param>
    /// <param name="constructor">The constructor symbol, if any.</param>
    private static void BuildFactoryMethod(MockDetails details, CodeBuilder builder, IMethodSymbol? constructor = null)
    {
        if (details.Target.TypeArguments.Length > 0)
            BuildGenericFactoryMethod(details, builder, constructor);
        else
            BuildNonGenericFactoryMethod(details, builder, constructor);
    }

    /// <summary>
    ///     Builds a non-generic factory method for the specified symbol.
    /// </summary>
    /// <param name="symbol">The symbol to build the factory method for.</param>
    /// <param name="builder">The code builder.</param>
    /// <param name="constructor">The constructor symbol, if any.</param>
    private static void BuildNonGenericFactoryMethod(MockDetails details, CodeBuilder builder, IMethodSymbol? constructor)
    {
        var constructorParameters = constructor?.Parameters ?? [];

        var parameters = constructorParameters.ToString(t => $"{t.Type} {t.Name}, ", "");
        var names = constructorParameters.ToString(t => $"{t.Name}, ", "");
        var doc = constructorParameters.ToString(t => $"///     <param name=\"{t.Name}\">Base constructor parameter {t.Name}.</param>\n", "");

        var symbolName = details.Target.Name;

        var cref = details.Target.ToCRef();

        builder.Add(
            $$"""
              /// <summary>
              ///     Creates a mock object for <see cref="{{cref}}"/>.
              /// </summary>
              {{doc}}///     <param name="config">Optional configuration for the mock object.</param>
              /// <returns>The mock object for <see cref="{{cref}}"/>.</returns>
              internal static {{details.SourceName}} {{symbolName}}
                  ({{parameters}}System.Action<{{details.Namespace}}.{{details.MockType}}.Config>? config = null)
                  => new {{details.Namespace}}.{{details.MockName}}({{names}}config);
              
              /// <summary>
              ///     Creates a mock object for <see cref="{{cref}}"/>.
              /// </summary>
              {{doc}}///     <param name="config{{symbolName}}">Outputs configuration for the mock object.</param>
              /// <returns>The mock object for <see cref="{{cref}}"/>.</returns>
              internal static {{details.SourceName}} {{symbolName}}
                  ({{parameters}}out {{details.Namespace}}.{{details.MockType}}.Config config{{symbolName}})
                  {
                     {{details.Namespace}}.{{details.MockName}}.Config outConfig = null!;
                     var result = new {{details.Namespace}}.{{details.MockName}}({{names}}config => outConfig = config);
                     config{{symbolName}} = outConfig;
                     return result;
                  }
              """);
    }
    
    /// <summary>
    ///     Builds a generic factory method for the specified symbol.
    /// </summary>
    /// <param name="symbol">The symbol to build the factory method for.</param>
    /// <param name="builder">The code builder.</param>
    /// <param name="constructor">The constructor symbol, if any.</param>
    private static void BuildGenericFactoryMethod(MockDetails details, CodeBuilder builder, IMethodSymbol? constructor = null)
    {
        var constructorParameters = constructor?.Parameters ?? [];

        var parameters = constructorParameters.ToString(t => $"{t.Type} {t.Name}, ", "");
        var arguments = constructorParameters.ToString(t => $"{t.Name}, ", "");
        var doc = constructorParameters.ToString(t => $"///     <param name=\"{t.Name}\">Base constructor parameter {t.Name}.</param>\n", "");

        var cref = details.Target.ToCRef();
        
        var types = details.Target.TypeArguments.ToString(t => t.Name);
        var constraints = details.Target.TypeArguments.ToConstraints();
        
        builder.Add(
            $$"""
              /// <summary>
              ///     Creates a mock object for <see cref="{{cref}}"/>.
              /// </summary>
              {{doc}}///     <param name="config">Optional configuration for the mock object.</param>
              /// <returns>The mock object for <see cref="{{cref}}"/>.</returns>
              internal static {{details.SourceName}} {{details.Target.Name}}<{{types}}>
                  ({{parameters}}System.Action<{{details.Namespace}}.{{details.MockType}}.Config>? config = null) {{constraints}}
                  => new {{details.Namespace}}.{{details.MockType}}({{arguments}}config);

              /// <summary>
              ///     Creates a mock object for <see cref="{{cref}}"/>.
              /// </summary>
              {{doc}}///     <param name="config">Outputs configuration for the mock object.</param>
              /// <returns>The mock object for <see cref="{{cref}}"/>.</returns>
              internal static {{details.SourceName}} {{details.Target.Name}}<{{types}}>
                  ({{parameters}}out {{details.Namespace}}.{{details.MockType}}.Config config) {{constraints}}
                  {
                     {{details.Namespace}}.{{details.MockType}}.Config outConfig = null!;
                     var result = new {{details.Namespace}}.{{details.MockType}}({{arguments}}config => outConfig = config);
                     config = outConfig;;
                     return result;
                  }
              """);
    }
}