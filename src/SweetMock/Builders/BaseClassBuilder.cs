namespace SweetMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using MemberBuilders;
using Microsoft.CodeAnalysis;
using Utils;

internal class BaseClassBuilder
{
    private static readonly IBaseClassBuilder[] builders = [new ConstructorBuilder(), new EventBuilder(), new PropertyBuilder(), new IndexBuilder(), new MethodBuilder(), new BackstopBuilder()];
    
    public CodeBuilder Build(MockDetails details)
    {
        var result = new CodeBuilder();
        var documentationName = details.SourceName.Replace("<", "{").Replace(">", "}");
        
        result.Add($$"""
                     // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                     #nullable enable
                     namespace {{details.Namespace}}
                     {
                     ->
                     /// <summary>
                     /// Mock implementation of <see cref="{{documentationName}}"/>. Should only be used for testing purposes.
                     /// </summary>
                     [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SourceGeneratorMetadata.Version}}")]
                     internal class {{details.MockType}} : {{details.SourceName}} {{details.Constraints}}
                     {
                     ->
                     #region Configuration
                     ->
                     private Config _config { get; }

                     /// <summary>
                     /// Configuration class for the mock.
                     /// </summary>
                     internal partial class Config
                     {
                         private readonly {{details.MockType}} target;
                     
                         /// <summary>
                         /// Initializes a new instance of the <see cref="Config"/> class.
                         /// </summary>
                         /// <param name="target">The target mock class.</param>
                         public Config({{details.MockType}} target)
                         {
                             this.target = target;
                         }
                     }
                     <-
                     #endregion
                     """);

        result.Add(LogBuilder.InitializeLogging());

        result.Add(BuildMembers(details));

        result.Add("""
                    <-
                    }
                    <-
                    }
                    """);
        
        return result;
    }

    private CodeBuilder BuildMembers(MockDetails details)
    {
        var result = new CodeBuilder();

        var members = GetMembers(details);

        if (members.All(t => t.Key != ".ctor"))
        {
            result.Add(ConstructorBuilder.BuildEmptyConstructor(details));
        }
        
        foreach (var member in members)
        {
            var wasAdded = builders.FirstOrDefault(t => t.TryBuildBase(details, result, member.ToArray()));
            
            if (wasAdded == null)
            {
                result.Add($"// {member.Key} was not handled {member.First()}");
            }
        }
        
        return result;
    }

    private static ILookup<string, ISymbol> GetMembers(MockDetails details)
    {
        var accessibilityFilter = new Func<Accessibility, bool>(accessibility => accessibility == Accessibility.Public || accessibility == Accessibility.Protected);

        var memberCandidates = details.Target.GetMembers().Where(t => accessibilityFilter(t.DeclaredAccessibility)).ToList();

        if (details.Target.TypeKind == TypeKind.Interface)
        {
            AddInheritedInterfaces(memberCandidates, details.Target);
        }

        return memberCandidates.Distinct(SymbolEqualityComparer.IncludeNullability).ToLookup(t => t.Name);
    }
    
    private static void AddInheritedInterfaces(List<ISymbol> memberCandidates, INamedTypeSymbol namedTypeSymbol)
    {
        var allInterfaces = namedTypeSymbol.AllInterfaces;
        foreach (var interface2 in allInterfaces)
        {
            memberCandidates.AddRange(interface2.GetMembers());
            AddInheritedInterfaces(memberCandidates, interface2);
        }
    }
}