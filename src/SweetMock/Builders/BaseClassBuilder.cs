namespace SweetMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using MemberBuilders;
using Microsoft.CodeAnalysis;
using Utils;

internal static class BaseClassBuilder
{
    public static CodeBuilder Build(MockDetails details)
    {
        CodeBuilder result = new();

        var documentationName = details.Target.ToCRef();

        result.Add($$"""
                     // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                     #nullable enable
                     namespace {{details.Namespace}}
                     {
                     ->
                     /// <summary>
                     /// Mock implementation of <see cref="{{documentationName}}"/>. Should only be used for testing purposes.
                     /// </summary>
                     [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SourceGeneratorMetadata.Version}}")]
                     internal class {{details.MockType}} : {{details.SourceName}} {{details.Constraints}}
                     {
                     ->
                     """);

        using (result.Region("Configuration"))
        {
            result.Add($$"""
                         private Config _config { get; }

                         /// <summary>
                         /// Configuration class for the mock.
                         /// </summary>
                         internal partial class Config
                         {
                             private readonly {{details.MockType}} target;

                             /// <summary>
                             /// Initializes a new instance of the <see cref="T:Config"/> class.
                             /// </summary>
                             /// <param name="target">The target mock class.</param>
                             public Config({{details.MockType}} target)
                             {
                                 this.target = target;
                             }
                         }
                        """);
        }

        result.Add(LogBuilder.InitializeLogging());

        result.Add(BuildMembers(details));

        result.Add("""
                    <-
                    }
                    <-
                    }
                    """);

        return result;
    }

    private static CodeBuilder BuildMembers(MockDetails details)
    {
        var result = new CodeBuilder();

        var allMembers = details.Target.GetMembers().ToList();
        AddInheritedInterfaces(allMembers, details.Target);
        var m = allMembers.Where(IsCandidate).ToArray();

        var constructors = m.OfType<IMethodSymbol>().Where(t => t.MethodKind == MethodKind.Constructor);
        result.Add(ConstructorBuilder.Build(details, constructors));

        m = m.Where(IsOverwritable).ToArray();

        var methods = m.OfType<IMethodSymbol>().Where(t => t.MethodKind == MethodKind.Ordinary);
        result.Add(MethodBuilder.Build(methods));

        var properties = m.OfType<IPropertySymbol>().Where(t => !t.IsIndexer);
        result.Add(PropertyBuilder.Build(properties));

        var indexers = m.OfType<IPropertySymbol>().Where(t => t.IsIndexer);
        result.Add(IndexBuilder.Build(indexers));

        var events = m.OfType<IEventSymbol>();
        result.Add(EventBuilder.Build(events));

        return result;
    }

    private static bool IsOverwritable(ISymbol t) => t.IsAbstract || t.IsVirtual;

    internal static void AddInheritedInterfaces(List<ISymbol> memberCandidates, INamedTypeSymbol namedTypeSymbol)
    {
        var allInterfaces = namedTypeSymbol.AllInterfaces;
        foreach (var inherited in allInterfaces)
        {
            memberCandidates.AddRange(inherited.GetMembers());
            AddInheritedInterfaces(memberCandidates, inherited);
        }
    }

    private static bool IsCandidate(ISymbol symbol) =>
        symbol is { IsStatic: false, IsSealed: false, DeclaredAccessibility: Accessibility.Public or Accessibility.Protected };
}
