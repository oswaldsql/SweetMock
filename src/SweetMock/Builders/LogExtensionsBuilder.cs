namespace SweetMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Utils;

internal class LogExtensionsBuilder
{
    public string BuildLogExtensions(MockDetails details)
    {
        var builder = new CodeBuilder();

        builder.Add($$"""
                      // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                      #nullable enable
                      namespace {{details.Namespace}} {

                      using System.Linq;
                      using System;
                      ->
                      [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SourceGeneratorMetadata.Version}}")]
                      internal static class LogExtensionsFor_{{details.MockName}} {
                      ->
                      """);

        builder.Add(BuildMembers(details));

        builder.Add("""
                    <-
                    }
                    <-
                    }

                    """);

        return builder.ToString();
    }

    private CodeBuilder BuildMembers(MockDetails details)
    {
        var result = new CodeBuilder();

        var members = details.GetMembers();

        foreach (var m in members)
        {
            var f = m.First();
            switch (f)
            {
                case IMethodSymbol {MethodKind: MethodKind.EventAdd or MethodKind.EventRaise or MethodKind.EventRemove or MethodKind.PropertyGet or MethodKind.PropertySet}:
                    break;
                case IMethodSymbol { MethodKind: MethodKind.Constructor }:
                    using (result.Region("Constructors"))
                    {
                        result.Add(TryBuildOverwrittenLoggingExtension(details, m.OfType<IMethodSymbol>().ToArray()));
                    }
                    break;
                case IMethodSymbol { MethodKind: MethodKind.Ordinary }:
                    using (result.Region("Method : " + m.Key))
                    {
                        result.Add(TryBuildOverwrittenLoggingExtension(details, m.OfType<IMethodSymbol>().ToArray()));
                    }
                    break;
                case IPropertySymbol { IsIndexer: false } propertySymbol:
                    using (result.Region("Property : " + m.Key))
                    {
                        result.Add(this.TryBuildLoggingExtension(propertySymbol.GetMethod));
                        result.Add(this.TryBuildLoggingExtension(propertySymbol.SetMethod));
                    }
                    break;
                case IPropertySymbol { IsIndexer: true } indexerSymbol:
                    using (result.Region("Indexer : " + m.Key))
                    {
                        result.Add(this.TryBuildLoggingExtension(indexerSymbol.GetMethod));
                        result.Add(this.TryBuildLoggingExtension(indexerSymbol.SetMethod));
                    }
                    break;
                case IEventSymbol eventSymbol:
                    using (result.Region("Event : " + m.Key))
                    {
                        result.Add(this.TryBuildLoggingExtension(eventSymbol.AddMethod));
                        result.Add(this.TryBuildLoggingExtension(eventSymbol.RemoveMethod));
                        result.Add(this.TryBuildLoggingExtension(eventSymbol.RaiseMethod));
                    }
                    break;
                default:
                    result.Add("//" + f);
                    break;
            }
        }

        return result;
    }

    public CodeBuilder TryBuildLoggingExtension(IMethodSymbol? methodSymbol)
    {
        CodeBuilder result = new();

        if(methodSymbol == null) { return result; }

        var propertyName = GetMethodName(methodSymbol);

        if (methodSymbol.ContainingType.TypeParameters.Length == 1)
        {
            throw new Exception($"{methodSymbol}");
        }

        var argsClass = $"{propertyName}_Args";

        result.Add(renderArgumentClass([methodSymbol], argsClass));

        result.Add(BuildPredicateDocumentation([methodSymbol]));

        result.Add($$"""
                     public static System.Collections.Generic.IEnumerable<SweetMock.TypedCallLogItem<{{argsClass}}>> {{propertyName}}(this System.Collections.Generic.IEnumerable<SweetMock.CallLogItem> log, Func<{{argsClass}}, bool>? predicate = null)
                     {
                         return log.Where(t => t.MethodSignature == "{{methodSymbol}}")
                             .Select(t => new SweetMock.TypedCallLogItem<{{argsClass}}>(t))
                             .Where(t => predicate == null || predicate(t.TypedArguments));
                     }
                     """);

        return result;
    }

    public string GetMethodName(IMethodSymbol methodSymbol) =>
        methodSymbol.MethodKind switch
        {
            MethodKind.Constructor => methodSymbol.ContainingType.Name,
            MethodKind.EventAdd => methodSymbol.Name.Substring(4) + "_Add",
            MethodKind.EventRaise => methodSymbol.Name.Substring(6) + "_Raise",
            MethodKind.EventRemove => methodSymbol.Name.Substring(7) + "_Remove",
            MethodKind.Ordinary => methodSymbol.Name,
            MethodKind.PropertyGet => methodSymbol.Name.Substring(4) + "_Get",
            MethodKind.PropertySet => methodSymbol.Name.Substring(4) + "_Set",
            _ => methodSymbol.Name
        };

    public CodeBuilder TryBuildOverwrittenLoggingExtension(MockDetails details, IMethodSymbol[] symbols)
    {
        if(symbols.Length == 1) return this.TryBuildLoggingExtension(symbols[0]);

        CodeBuilder result = new();

        var first = symbols.First();
        if (first is IPropertySymbol or IEventSymbol) return result;

        var propertyName = GetMethodName(symbols[0]);

        if (first is IMethodSymbol)
        {
            var methodSymbol = (IMethodSymbol)first;

            if (methodSymbol.ContainingType.TypeParameters.Length == 0)
            {
                var argsClass = $"{propertyName}_Args";

                result.Add(renderArgumentClass(symbols, argsClass));

                var signatures = string.Join(", ", symbols.Select(t => $"\"{t}\""));

                result.Add($"private static System.Collections.Generic.HashSet<string> {propertyName}_Signatures = new System.Collections.Generic.HashSet<string> {{{signatures}}};").Add();

                result.Add(BuildPredicateDocumentation(symbols));

                result.Add($$"""
                             public static System.Collections.Generic.IEnumerable<SweetMock.TypedCallLogItem<{{argsClass}}>> {{propertyName}}(this System.Collections.Generic.IEnumerable<SweetMock.CallLogItem> log, Func<{{argsClass}}, bool>? predicate = null)
                             {
                                 return log.Where(t => {{propertyName}}_Signatures.Contains("{{first}}"))
                                     .Select(t => new SweetMock.TypedCallLogItem<{{argsClass}}>(t))
                                     .Where(t => predicate == null || predicate(t.TypedArguments));
                             }
                             """);
            }
        }

        return result;
    }

    private static CodeBuilder renderArgumentClass(IMethodSymbol[] symbols, string argsClass)
    {
        CodeBuilder result = new();

        if(symbols.Length == 0)
            return result.Add($"public class {argsClass} : SweetMock.TypedArguments {{ }}").Add();

        var lookup = symbols.OfType<IMethodSymbol>().SelectMany(t => t.Parameters).ToLookup(t => t.Name);
        result.Add($"public class {argsClass} : SweetMock.TypedArguments {{").Indent();
        foreach (var l in lookup)
            if (l.Count() > 1)
            {
                result.Add($"public object? {l.Key} => base.Arguments[\"{l.Key}\"]!;");
            }
            else if(l.First().Type is ITypeParameterSymbol)
            {
                result.Add($"public object? {l.Key} => base.Arguments[\"{l.Key}\"]!;");
            }
            else
            {
                var p = l.First();
                result.Add($"public {p.Type} {p.Name} => ({p.Type})base.Arguments[\"{p.Name}\"]!;");
            }

        result.Unindent().Add("}");

        return result;
    }

    private static CodeBuilder BuildPredicateDocumentation(ISymbol[] symbols)
    {
        CodeBuilder result = new();
        result.Add("/// <summary>");
        foreach (var symbol in symbols)
        {
            result.Add($"/// <see cref=\"{symbol.ToCRef()}\"/>");
        }
        result.Add("/// </summary>");
        return result;
    }
}
