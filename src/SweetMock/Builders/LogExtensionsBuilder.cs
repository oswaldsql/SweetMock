namespace SweetMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Utils;

internal class LogExtensionsBuilder
{
    public string BuildLogExtensions(MockDetails details)
    {
        var builder = new CodeBuilder();

        builder.Add($$"""
                      // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                      #nullable enable
                      namespace {{details.Namespace}} {
                      
                      using System.Linq;
                      using System;
                      ->
                      [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SourceGeneratorMetadata.Version}}")]
                      internal static class LogExtensionsFor_{{details.MockName}} {
                      ->
                      """);

        builder.Add(BuildMembers(details));

        builder.Add("""
                    <-
                    }
                    <-
                    }

                    """);

        return builder.ToString();
    }

    private CodeBuilder BuildMembers(MockDetails details)
    {
        var result = new CodeBuilder();

        var members = details.GetMembers();

        foreach (var m in members)
        {
            var f = m.First();
            switch (f)
            {
                case IMethodSymbol {MethodKind: MethodKind.EventAdd or MethodKind.EventRaise or MethodKind.EventRemove or MethodKind.PropertyGet or MethodKind.PropertySet}:
                    break;
                case IMethodSymbol { MethodKind: MethodKind.Constructor }:
                    using (result.Region("Constructors"))
                    {
                        TryBuildOverwrittenLoggingExtension(details, result, m.OfType<IMethodSymbol>().ToArray());
                    }
                    break;
                case IMethodSymbol { MethodKind: MethodKind.Ordinary }:
                    using (result.Region("Method : " + m.Key))
                    {
                        TryBuildOverwrittenLoggingExtension(details, result, m.OfType<IMethodSymbol>().ToArray());
                    }
                    break;
                case IPropertySymbol { IsIndexer: false } propertySymbol:
                    using (result.Region("Property : " + m.Key))
                    {
                        TryBuildLoggingExtension(details, result, propertySymbol.GetMethod);
                        TryBuildLoggingExtension(details, result, propertySymbol.SetMethod);
                    }
                    break;
                case IPropertySymbol { IsIndexer: true } indexerSymbol:
                    using (result.Region("Indexer : " + m.Key))
                    {
                        TryBuildLoggingExtension(details, result, indexerSymbol.GetMethod);
                        TryBuildLoggingExtension(details, result, indexerSymbol.SetMethod);
                    }
                    break;
                case IEventSymbol eventSymbol:
                    using (result.Region("Event : " + m.Key))
                    {
                        TryBuildLoggingExtension(details, result, eventSymbol.AddMethod);
                        TryBuildLoggingExtension(details, result, eventSymbol.RemoveMethod);
                        TryBuildLoggingExtension(details, result, eventSymbol.RaiseMethod);
                    }
                    break;
                default:
                    result.Add("//" + f);
                    break;
            }
        }

        return result;
    }

    public bool TryBuildLoggingExtension(MockDetails details, CodeBuilder result, IMethodSymbol? methodSymbol)
    {
        if(methodSymbol == null) { return false; }
        
        var propertyName = methodSymbol.Name;
        if (propertyName == ".ctor") propertyName = details.Target.Name;

        if (methodSymbol.ContainingType.TypeParameters.Length == 1)
        {
            throw new Exception($"{methodSymbol}");
        }
        
        var argsClass = $"{propertyName}_Args";

        result.Add(renderArgumentClass([methodSymbol], argsClass));
        
        result.Add(BuildPredicateDocumentation([methodSymbol]));

        result.Add($$"""
                     public static System.Collections.Generic.IEnumerable<SweetMock.TypedCallLogItem<{{argsClass}}>> {{propertyName}}(this System.Collections.Generic.IEnumerable<SweetMock.CallLogItem> log, Func<{{argsClass}}, bool>? predicate = null)
                     {
                         return log.Where(t => t.MethodSignature == "{{methodSymbol}}")
                             .Select(t => new SweetMock.TypedCallLogItem<{{argsClass}}>(t))
                             .Where(t => predicate == null || predicate(t.TypedArguments));
                     }    
                     """);

        return true;
    }

    public bool TryBuildOverwrittenLoggingExtension(MockDetails details, CodeBuilder result, IMethodSymbol[] symbols)
    {
        if(symbols.Length == 1) return TryBuildLoggingExtension(details, result, symbols[0]);
        
        var first = symbols.First();
        if (first is IPropertySymbol or IEventSymbol) return true;

        var propertyName = symbols.First().Name;
        if (propertyName == ".ctor") propertyName = details.Target.Name;

        if (first is IMethodSymbol)
        {
            var methodSymbol = (IMethodSymbol)first;

            if (methodSymbol.ContainingType.TypeParameters.Length == 0)
            {
                var argsClass = $"{propertyName}_Args";

                result.Add(renderArgumentClass(symbols, argsClass));

                var signatures = string.Join(", ", symbols.Select(t => $"\"{t}\""));
                
                result.Add($"private static System.Collections.Generic.HashSet<string> {propertyName}_Signatures = new System.Collections.Generic.HashSet<string> {{{signatures}}};").Add();

                result.Add(BuildPredicateDocumentation(symbols));

                result.Add($$"""
                             public static System.Collections.Generic.IEnumerable<SweetMock.TypedCallLogItem<{{argsClass}}>> {{propertyName}}(this System.Collections.Generic.IEnumerable<SweetMock.CallLogItem> log, Func<{{argsClass}}, bool>? predicate = null)
                             {
                                 return log.Where(t => {{propertyName}}_Signatures.Contains("{{first}}"))
                                     .Select(t => new SweetMock.TypedCallLogItem<{{argsClass}}>(t))
                                     .Where(t => predicate == null || predicate(t.TypedArguments));
                             }    
                             """);
            }
        }

        return true;
    }

    private static CodeBuilder renderArgumentClass(IMethodSymbol[] symbols, string argsClass)
    {
        CodeBuilder result = new();
        
        if(symbols.Length == 0)
            result.Add($"public class {argsClass} : SweetMock.TypedArguments {{ }}").Add();
        
        var lookup = symbols.OfType<IMethodSymbol>().SelectMany(t => t.Parameters).ToLookup(t => t.Name);
        result.Add($"public class {argsClass} : SweetMock.TypedArguments {{").Indent();
        foreach (var l in lookup)
            if (l.Count() > 1)
            {
                result.Add($"public object? {l.Key} => base.Arguments[\"{l.Key}\"]!;");
            }
            else if(l.First().Type is ITypeParameterSymbol)
            {
                result.Add($"public object? {l.Key} => base.Arguments[\"{l.Key}\"]!;");
            }
            else
            {
                var p = l.First();
                result.Add($"public {p.Type} {p.Name} => ({p.Type})base.Arguments[\"{p.Name}\"]!;");
            }
        
        result.Unindent().Add("}");

        return result;
    }

    private static CodeBuilder BuildPredicateDocumentation(ISymbol[] symbols)
    {
        CodeBuilder result = new();
        result.Add("/// <summary>");
        foreach (var symbol in symbols)
        {
            result.Add($"/// <see cref=\"{symbol.ToCRef()}\"/>");
        }
        result.Add("/// </summary>");
        return result;
    }
}