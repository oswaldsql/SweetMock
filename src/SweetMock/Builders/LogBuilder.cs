namespace SweetMock.Builders;

using System;
using System.Collections.Generic;
using System.Linq;
using MemberBuilders;
using Microsoft.CodeAnalysis;
using SweetMock.Utils;

public class LogBuilder
{
    private static readonly ILoggingExtensionBuilder[] builders = [new ConstructorBuilder(), new EventBuilder(), new PropertyBuilder(), new IndexBuilder(), new MethodBuilder(), new BackstopBuilder()];

    public string BuildLogExtensions(MockDetails details)
    {
        var builder = new CodeBuilder();

        builder.Add($$"""
                      // Generated by SweetMock {{SourceGeneratorMetadata.Version}} on {{DateTimeOffset.Now:u}}
                      #nullable enable
                      namespace {{details.Namespace}} {
                      ->
                      [System.CodeDom.Compiler.GeneratedCode("SweetMock","{{SourceGeneratorMetadata.Version}}")]
                      internal static class LogExtensionsFor_{{details.MockName}} {
                      ->
                      """);

        builder.Add(BuildMembers(details));
        
        builder.Add($$"""
                      <-
                      }
                      <-
                      }
                      
                      """);

        return builder.ToString();
    }

    private CodeBuilder BuildMembers(MockDetails details)
    {
        var result = new CodeBuilder();

        var members = GetMembers(details);

//        if (members.All(t => t.Key != ".ctor"))
//        {
//            result.Add(ConstructorBuilder.BuildEmptyConstructor(details));
//        }
        
        foreach (var member in members)
        {
            var wasAdded = builders.FirstOrDefault(t => t.TryBuildLoggingExtension(details, result, member.ToArray()));
            
            if (wasAdded == null)
            {
                result.Add($"// {member.Key} was not handled {member.First()}");
            }
        }
        
        return result;
    }
    
    private static ILookup<string, ISymbol> GetMembers(MockDetails details)
    {
        var accessibilityFilter = new Func<Accessibility, bool>(accessibility => accessibility == Accessibility.Public || accessibility == Accessibility.Protected);

        var memberCandidates = details.Target.GetMembers().Where(t => accessibilityFilter(t.DeclaredAccessibility)).ToList();

        if (details.Target.TypeKind == TypeKind.Interface)
        {
            AddInheritedInterfaces(memberCandidates, details.Target);
        }

        return memberCandidates.Distinct(SymbolEqualityComparer.IncludeNullability).ToLookup(t => t.Name);
    }
    
    private static void AddInheritedInterfaces(List<ISymbol> memberCandidates, INamedTypeSymbol namedTypeSymbol)
    {
        var allInterfaces = namedTypeSymbol.AllInterfaces;
        foreach (var interface2 in allInterfaces)
        {
            memberCandidates.AddRange(interface2.GetMembers());
            AddInheritedInterfaces(memberCandidates, interface2);
        }
    }
    
    private static readonly Func<Accessibility, bool> accessibilityFilter = accessibility => accessibility == Accessibility.Public || accessibility == Accessibility.Protected;

    public static string InitializeLogging() =>
        $$"""
          # region Logging
          ->

          private bool _hasLog = false;
          private SweetMock.CallLog _log = new SweetMock.CallLog();
          
          /// <summary>
          /// Adding logging to the configuration.
          /// </summary>
          internal partial class Config
          {
            public Config LogCallsTo(SweetMock.CallLog callLog) {
                target._log = callLog;
                target._hasLog = true;
                return this;
            }
          }
          <-
          #endregion
          """;

    public static string BuildLogSegment(IMethodSymbol? symbol, bool skipParameters = false)
    {
        if (symbol == null) { return "";}

        string logSegment;
        if (!skipParameters && symbol.Parameters.Any(t => t.RefKind == RefKind.None))
        {
            var LogArgumentsValue = symbol.Parameters.Where(t => t.RefKind == RefKind.None).Select(argument);
            logSegment = $$"""
                           if(_hasLog) {
                           ->
                             _log.Add("{{symbol}}", SweetMock.Arguments{{string.Join("", LogArgumentsValue)}});
                           }
                           <-
                           """;
        }
        else
        {
            logSegment = $$"""
                           if(_hasLog) {
                           ->
                             _log.Add("{{symbol}}");
                           }
                           <-
                           """;
        }

        return logSegment;
    }

    private static string argument(IParameterSymbol t, int i)
    {
        return i == 0 ? $".With(\"{t.Name}\", {t.Name})" : $".And(\"{t.Name}\", {t.Name})";
    }
}
